<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通过java生成七牛云uptoken]]></title>
    <url>%2F%E9%80%9A%E8%BF%87java%E7%94%9F%E6%88%90%E4%B8%83%E7%89%9B%E4%BA%91uptoken.html</url>
    <content type="text"><![CDATA[写在前面最近在写一个图片分享网站类型的小 demo，使用七牛云图片上传需要服务端生成上传凭证 uptoken。本来对后端了解的不是很多，看了官网的说明，写了一个最基本的生成方法，所以总结一下生成 uptoken 的具体步骤。我这里介绍的是使用七牛云 Java SDK 的生成方法。 简介 此 SDK 适用于 Java 7 及以上版本。使用此 SDK 构建您的网络应用程序，能让您以非常便捷地方式将数据安全地存储 到七牛云上。无论您的网络应用是一个网站程序，还是包括从云端（服务端程序）到终端（手持设备应用）的架构服务或应 用，通过七牛云及其 SDK，都能让您应用程序的终端用户高速上传和下载，同时也让您的服务端更加轻盈。Java SDK 属于七牛服务端 SDK 之一，主要有如下功能： 提供生成客户端上传所需的上传凭证的功能 提供文件从服务端直接上传七牛的功能 提供对七牛空间中文件进行管理的功能 提供对七牛空间中文件进行处理的功能 提供七牛 CDN 相关的刷新，预取，日志功能 官方文档 七牛云 java-sdk 官方文档 安装我们需要安装七牛云的 java-sdk，我这里介绍的是 Maven 的安装方法 12345&lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;[7.2.0, 7.2.99]&lt;/version&gt;&lt;/dependency&gt; 这里的 version 指定了一个版本范围，每次更新 pom.xml 的时候会尝试去下载 7.2.x 版本中的最新版本，我们也可以手动指定一个固定的版本。 使用引入 java-sdk 以后，我们需要创建一个 Auth 类，这个类的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331package com.qiniu.util;import com.qiniu.http.Client;import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;import java.net.URI;import java.security.GeneralSecurityException;public final class Auth &#123; /** * 上传策略 * 参考文档：&lt;a href="https://developer.qiniu.com/kodo/manual/put-policy"&gt;上传策略&lt;/a&gt; */ private static final String[] policyFields = new String[]&#123; "callbackUrl", "callbackBody", "callbackHost", "callbackBodyType", "callbackFetchKey", "returnUrl", "returnBody", "endUser", "saveKey", "insertOnly", "isPrefixalScope", "detectMime", "mimeLimit", "fsizeLimit", "fsizeMin", "persistentOps", "persistentNotifyUrl", "persistentPipeline", "deleteAfterDays", "fileType", &#125;; private static final String[] deprecatedPolicyFields = new String[]&#123; "asyncOps", &#125;; public final String accessKey; private final SecretKeySpec secretKey; private Auth(String accessKey, SecretKeySpec secretKeySpec) &#123; this.accessKey = accessKey; this.secretKey = secretKeySpec; &#125; public static Auth create(String accessKey, String secretKey) &#123; if (StringUtils.isNullOrEmpty(accessKey) || StringUtils.isNullOrEmpty(secretKey)) &#123; throw new IllegalArgumentException("empty key"); &#125; byte[] sk = StringUtils.utf8Bytes(secretKey); SecretKeySpec secretKeySpec = new SecretKeySpec(sk, "HmacSHA1"); return new Auth(accessKey, secretKeySpec); &#125; private static void copyPolicy(final StringMap policy, StringMap originPolicy, final boolean strict) &#123; if (originPolicy == null) &#123; return; &#125; originPolicy.forEach(new StringMap.Consumer() &#123; @Override public void accept(String key, Object value) &#123; if (StringUtils.inStringArray(key, deprecatedPolicyFields)) &#123; throw new IllegalArgumentException(key + " is deprecated!"); &#125; if (!strict || StringUtils.inStringArray(key, policyFields)) &#123; policy.put(key, value); &#125; &#125; &#125;); &#125; private Mac createMac() &#123; Mac mac; try &#123; mac = javax.crypto.Mac.getInstance("HmacSHA1"); mac.init(secretKey); &#125; catch (GeneralSecurityException e) &#123; e.printStackTrace(); throw new IllegalArgumentException(e); &#125; return mac; &#125; public String sign(byte[] data) &#123; Mac mac = createMac(); String encodedSign = UrlSafeBase64.encodeToString(mac.doFinal(data)); return this.accessKey + ":" + encodedSign; &#125; public String sign(String data) &#123; return sign(StringUtils.utf8Bytes(data)); &#125; public String signWithData(byte[] data) &#123; String s = UrlSafeBase64.encodeToString(data); return sign(StringUtils.utf8Bytes(s)) + ":" + s; &#125; public String signWithData(String data) &#123; return signWithData(StringUtils.utf8Bytes(data)); &#125; /** * 生成HTTP请求签名字符串 * * @param urlString * @param body * @param contentType * @return */ public String signRequest(String urlString, byte[] body, String contentType) &#123; URI uri = URI.create(urlString); String path = uri.getRawPath(); String query = uri.getRawQuery(); Mac mac = createMac(); mac.update(StringUtils.utf8Bytes(path)); if (query != null &amp;&amp; query.length() != 0) &#123; mac.update((byte) ('?')); mac.update(StringUtils.utf8Bytes(query)); &#125; mac.update((byte) '\n'); if (body != null &amp;&amp; Client.FormMime.equalsIgnoreCase(contentType)) &#123; mac.update(body); &#125; String digest = UrlSafeBase64.encodeToString(mac.doFinal()); return this.accessKey + ":" + digest; &#125; /** * 验证回调签名是否正确 * * @param originAuthorization 待验证签名字符串，以 "QBox "作为起始字符 * @param url 回调地址 * @param body 回调请求体。原始请求体，不要解析后再封装成新的请求体--可能导致签名不一致。 * @param contentType 回调ContentType * @return */ public boolean isValidCallback(String originAuthorization, String url, byte[] body, String contentType) &#123; String authorization = "QBox " + signRequest(url, body, contentType); return authorization.equals(originAuthorization); &#125; /** * 下载签名 * * @param baseUrl 待签名文件url，如 http://img.domain.com/u/3.jpg 、 * http://img.domain.com/u/3.jpg?imageView2/1/w/120 * @return */ public String privateDownloadUrl(String baseUrl) &#123; return privateDownloadUrl(baseUrl, 3600); &#125; /** * 下载签名 * * @param baseUrl 待签名文件url，如 http://img.domain.com/u/3.jpg 、 * http://img.domain.com/u/3.jpg?imageView2/1/w/120 * @param expires 有效时长，单位秒。默认3600s * @return */ public String privateDownloadUrl(String baseUrl, long expires) &#123; long deadline = System.currentTimeMillis() / 1000 + expires; return privateDownloadUrlWithDeadline(baseUrl, deadline); &#125; public String privateDownloadUrlWithDeadline(String baseUrl, long deadline) &#123; StringBuilder b = new StringBuilder(); b.append(baseUrl); int pos = baseUrl.indexOf("?"); if (pos &gt; 0) &#123; b.append("&amp;e="); &#125; else &#123; b.append("?e="); &#125; b.append(deadline); String token = sign(StringUtils.utf8Bytes(b.toString())); b.append("&amp;token="); b.append(token); return b.toString(); &#125; /** * scope = bucket * 一般情况下可通过此方法获取token * * @param bucket 空间名 * @return 生成的上传token */ public String uploadToken(String bucket) &#123; return uploadToken(bucket, null, 3600, null, true); &#125; /** * scope = bucket:key * 同名文件覆盖操作、只能上传指定key的文件可以可通过此方法获取token * * @param bucket 空间名 * @param key key，可为 null * @return 生成的上传token */ public String uploadToken(String bucket, String key) &#123; return uploadToken(bucket, key, 3600, null, true); &#125; /** * 生成上传token * * @param bucket 空间名 * @param key key，可为 null * @param expires 有效时长，单位秒 * @param policy 上传策略的其它参数，如 new StringMap().put("endUser", "uid").putNotEmpty("returnBody", "")。 * scope通过 bucket、key间接设置，deadline 通过 expires 间接设置 * @return 生成的上传token */ public String uploadToken(String bucket, String key, long expires, StringMap policy) &#123; return uploadToken(bucket, key, expires, policy, true); &#125; /** * 生成上传token * * @param bucket 空间名 * @param key key，可为 null * @param expires 有效时长，单位秒。默认3600s * @param policy 上传策略的其它参数，如 new StringMap().put("endUser", "uid").putNotEmpty("returnBody", "")。 * scope通过 bucket、key间接设置，deadline 通过 expires 间接设置 * @param strict 是否去除非限定的策略字段，默认true * @return 生成的上传token */ public String uploadToken(String bucket, String key, long expires, StringMap policy, boolean strict) &#123; long deadline = System.currentTimeMillis() / 1000 + expires; return uploadTokenWithDeadline(bucket, key, deadline, policy, strict); &#125; public String uploadTokenWithDeadline(String bucket, String key, long deadline, StringMap policy, boolean strict) &#123; // TODO UpHosts Global String scope = bucket; if (key != null) &#123; scope = bucket + ":" + key; &#125; StringMap x = new StringMap(); copyPolicy(x, policy, strict); x.put("scope", scope); x.put("deadline", deadline); String s = Json.encode(x); return signWithData(StringUtils.utf8Bytes(s)); &#125; public String uploadTokenWithPolicy(Object obj) &#123; String s = Json.encode(obj); return signWithData(StringUtils.utf8Bytes(s)); &#125; public StringMap authorization(String url, byte[] body, String contentType) &#123; String authorization = "QBox " + signRequest(url, body, contentType); return new StringMap().put("Authorization", authorization); &#125; public StringMap authorization(String url) &#123; return authorization(url, null, null); &#125; /** * 生成HTTP请求签名字符串 * * @param urlString * @param body * @param contentType * @return */ public String signRequestV2(String urlString, String method, byte[] body, String contentType) &#123; URI uri = URI.create(urlString); Mac mac = createMac(); StringBuilder sb = new StringBuilder(); sb.append(String.format("%s %s", method, uri.getPath())); if (uri.getQuery() != null) &#123; sb.append(String.format("?%s", uri.getQuery())); &#125; sb.append(String.format("\nHost: %s", uri.getHost())); if (uri.getPort() &gt; 0) &#123; sb.append(String.format(":%d", uri.getPort())); &#125; if (contentType != null) &#123; sb.append(String.format("\nContent-Type: %s", contentType)); &#125; // body sb.append("\n\n"); if (body != null &amp;&amp; body.length &gt; 0 &amp;&amp; !StringUtils.isNullOrEmpty(contentType)) &#123; if (contentType.equals(Client.FormMime) || contentType.equals(Client.JsonMime)) &#123; sb.append(new String(body)); &#125; &#125; System.out.println(sb.toString()); mac.update(StringUtils.utf8Bytes(sb.toString())); String digest = UrlSafeBase64.encodeToString(mac.doFinal()); return this.accessKey + ":" + digest; &#125; public StringMap authorizationV2(String url, String method, byte[] body, String contentType) &#123; String authorization = "Qiniu " + signRequestV2(url, method, body, contentType); return new StringMap().put("Authorization", authorization); &#125; public StringMap authorizationV2(String url) &#123; return authorizationV2(url, "GET", null, null); &#125;&#125; 如果出现报错，只要导入相应的包即可，Auth 代码的 github 地址为 Auth 代码 github 地址 创建 Auth 类后，下面我们就来看一下如何生成一个最简单的上传凭证。最简单的上传凭证只需要 AccessKey，SecretKey 和 Bucket 就可以。 123456String accessKey = "access key";//七牛云账号对应的公匙String secretKey = "secret key";//七牛云账号对应的司匙String bucket = "bucket name";//上传图片到的存储空间Auth auth = Auth.create(accessKey, secretKey);String upToken = auth.uploadToken(bucket);//获取uptoken 接口示例我在这里展示一下我的 demo 中获取 uptoken 接口的示例，大家可以参考一下 1234567891011121314151617181920212223242526package com.photoshareweb.controller;import com.photoshareweb.common.Auth;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(value = "/PhotoShareWeb/share/auth")public class AuthController &#123; //通过七牛云上传凭证 @RequestMapping(value = "/getUpToken",method = RequestMethod.GET) public @ResponseBody String getUpToken()&#123; String accessKey = "access key";//七牛云账号对应的公匙 String secretKey = "secret key";//七牛云账号对应的司匙 String bucket = "bucket name";//上传图片到的存储空间 Auth auth = Auth.create(accessKey, secretKey); String upToken = auth.uploadToken(bucket); return upToken; &#125;&#125; 写在最后好啦，这样我们就可以生成一个最基本的 uptoken 了，当然只是最基本的，更多的用法大家可以参考官方文档。]]></content>
      <categories>
        <category>七牛云</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过js实现七牛云图片上传]]></title>
    <url>%2F%E9%80%9A%E8%BF%87js%E5%AE%9E%E7%8E%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.html</url>
    <content type="text"><![CDATA[写在前面最近在做一个图片分享网站类型的小 demo，我的想法是将用户上传的图片保存到七牛云上，然后将获取的链接存入数据库中。虽然以前写博客一直都是用七牛云来存储配图，但对于如何通过七牛云 JS 的 SDK 来完成上传操作还真是不太了解。在看了官网的教程后，有一些地方不是很明确，查了一些资料，所以总结一下前端如何通过 js 上传图片到七牛云。 官方文档 七牛云 Qiniu-JavaScript-SDK 官方文档 概述 Qiniu-JavaScript-SDK （下文简称为 JS-SDK）适用于 IE8+、Chrome、Firefox、Safari 等浏览器，基于七牛云存储官方 API 构建，其中上传功能基于 Plupload 插件封装。开发者基于 JS-SDK 可以方便的从浏览器端上传文件至七牛云存储，并对上传成功后的图片进行丰富的数据处理操作。 安装因为七牛云的 JS-SDK 是基于 Plupload 插件封装的，所以我们需要在引入七牛云的 js 依赖文件前，引入 Plupload 的相关 js 依赖文件。我这里介绍使用 NPM 安装的方法。 Plupload 下载 1npm install Plupload --save-dev qiniu-js 下载 1npm install qiniu-js --save-dev 使用在使用前我们需要在页面里引入相应的 js 依赖文件。 在页面中引入 plupload，plupload.full.min.js（生产环境）或 引入 plupload.dev.js 和 moxie.js（开发调试）。这些 js 文件可在 node_modules 文件夹下的 plupload 的文件夹中找到。 在页面中引入 qiniu.min.js（生产环境）或 qiniu.js（开发调试）这些 js 文件可在 node_modules 文件夹下的 qiniu-js 的文件夹中找到。 例如 1234//import js 具体路径可能会不同require("../../js/qiniu/plupload/plupload.dev.js");require("../../js/qiniu/plupload/moxie.js");require("../../js/qiniu/qiniu.js"); 然后需要在页面中初始化 uploader，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var uploader = Qiniu.uploader(&#123; disable_statistics_report: false, // 禁止自动发送上传统计信息到七牛，默认允许发送 runtimes: "html5,flash,html4", // 上传模式,依次退化 browse_button: "pickfiles", // 上传选择的点选按钮，**必需** // 在初始化时，uptoken, uptoken_url, uptoken_func 三个参数中必须有一个被设置 // 切如果提供了多个，其优先级为 uptoken &gt; uptoken_url &gt; uptoken_func // 其中 uptoken 是直接提供上传凭证，uptoken_url 是提供了获取上传凭证的地址，如果需要定制获取 uptoken 的过程则可以设置 uptoken_func uptoken: "&lt;Your upload token&gt;", // uptoken 是上传凭证，由其他程序生成 // uptoken_url: "/uptoken", // Ajax 请求 uptoken 的 Url，**强烈建议设置**（服务端提供） // uptoken_func: function(file)&#123; // 在需要获取 uptoken 时，该方法会被调用 // // do something // return uptoken; // &#125;, get_new_uptoken: false, // 设置上传文件的时候是否每次都重新获取新的 uptoken // downtoken_url: '/downtoken', // Ajax请求downToken的Url，私有空间时使用,JS-SDK 将向该地址POST文件的key和domain,服务端返回的JSON必须包含`url`字段，`url`值为该文件的下载地址 unique_names: false, // 默认 false，key 为文件名。若开启该选项，JS-SDK 会为每个文件自动生成key（文件名） save_key: false, // 默认 false。若在服务端生成 uptoken 的上传策略中指定了 `save_key`，则开启，SDK在前端将不对key进行任何处理 domain: "&lt;Your upload token&gt;", // bucket 域名（就是你在七牛云上创建的存储空间的测试域名），下载资源时用到，如：'http://xxx.bkt.clouddn.com/' **必需** container: "container", // 上传区域 DOM ID，默认是 browser_button 的父元素， max_file_size: "10mb", // 最大文件体积限制 flash_swf_url: "../plupload/Moxie.swf", //引入 flash,相对路径，这个也可以在 plupload 的文件夹中找到 max_retries: 3, // 上传失败最大重试次数 dragdrop: true, // 开启可拖曳上传 drop_element: "photo-container", // 拖曳上传区域元素的 ID，拖曳文件或文件夹后可触发上传 chunk_size: "4mb", // 分块上传时，每块的体积 auto_start: true, // 选择文件后自动上传，若关闭需要自己绑定事件触发上传, //x_vars : &#123; // 自定义变量，参考http://developer.qiniu.com/docs/v6/api/overview/up/response/vars.html // 'time' : function(up,file) &#123; // var time = (new Date()).getTime(); // do something with 'time' // return time; // &#125;, // 'size' : function(up,file) &#123; // var size = file.size; // do something with 'size' // return size; // &#125; //&#125;, init: &#123; FilesAdded: function(up, files) &#123; plupload.each(files, function(file) &#123; // 文件添加进队列后,处理相关的事情 &#125;); &#125;, BeforeUpload: function(up, file) &#123; // 每个文件上传前,处理相关的事情 console.log("上传开始"); &#125;, UploadProgress: function(up, file) &#123; // 每个文件上传时,处理相关的事情 console.log("上传中"); &#125;, FileUploaded: function(up, file, info) &#123; // 每个文件上传成功后,处理相关的事情 // 其中 info.response 是文件上传成功后，服务端返回的json，形式如 // &#123; // "hash": "Fh8xVqod2MQ1mocfI4S4KpRL6D98", // "key": "gogopher.jpg" // &#125; // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html var domain = up.getOption("domain"); var res = JSON.parse(info.response); var sourceLink = domain + res.key; //获取上传成功后的文件的Url; &#125;, Error: function(up, err, errTip) &#123; base.hideLoading(); //上传出错时,处理相关的事情 if (file.code == "-600") &#123; base.showAlertDialog("上传图片的大小不能超过10mb！"); &#125; else if (file.code == "-601") &#123; base.showAlertDialog("上传图片的格式有误！"); &#125; else &#123; base.showAlertDialog(err); &#125; &#125;, UploadComplete: function() &#123; //队列文件处理完毕后,处理相关的事情 &#125;, Key: function(up, file) &#123; // 若想在前端对每个文件的key进行个性化处理，可以配置该函数 // 我使用的是图片名加上当前时间来定义key // 该配置必须要在 unique_names: false , save_key: false 时才生效 // do something with key here var timestamp = Date.parse(new Date()); var key = file.name + "/" + timestamp; return key; &#125; &#125; // domain 为七牛空间（bucket)对应的域名，选择某个空间后，可通过"空间设置-&gt;基本设置-&gt;域名设置"查看获取 // uploader 为一个 plupload 对象，继承了所有 plupload 的方法，参考http://plupload.com/docs&#125;); 以上 uploader 的配置适用于单文件上传的情况。相信小伙伴们看完都有一个疑惑，什么是 uptoken 呢？ uptoken 是 我们图片上传的上传凭证，它会根据你的 Access Key 和 Secret Key 还有你上传图片到的存储空间 bucket 来生成(最基本的三项)。那么怎么生成 uptoken 呢？这当然不是由我们前端自己来生成的，这个时候就需要我们后端的小伙伴来帮帮忙了。具体可以参考我的另一篇博客通过 java 生成七牛云 uptoken。 写在最后关于七牛云上传组件的用法还有很多，如对上传的图片生成水印等，大家可以好好参考一下官方文档。我总结的只是一些最简单的用法，目前我的小 demo 只需要用到这一些，以后有需要再继续拓展 :)]]></content>
      <categories>
        <category>七牛云</category>
      </categories>
      <tags>
        <tag>七牛云</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown—文档解读]]></title>
    <url>%2FMarkdownStudy.html</url>
    <content type="text"><![CDATA[写在前面记得第一次接触 Markdown 应该是在 github 上，当时看每一个仓库里的 README 文档都是 md 格式的，文档内容的排版让我眼前一亮。诶这是什么东西，好奇的我赶紧百度了一下，看完官方文档，感觉自己推开了新世界的大门，有没有很方便！看完文档后，感觉文档一些东西介绍的有一点晦涩，不容易理解。所以我就想分享一下我对 Markdown 的一些认识。 一、认识 Markdown什么是 Markdown Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown 其实是一种文档编辑的标记语言，它的目标是实现「易读易写」，成为一种适用于网络的书写语言。那怎样才能算易读易写呢？我们在书写文档时，有时候最头疼的就是文章的排版问题，这个时候使用 Markdown 就很方便了。试想一下在写文档时，用键盘一气呵成敲好内容，而且这个时候文章已经排版好了，大声告诉我，是不是很方便。现在很多网站都支持 Markdown 形式的文档书写，比如简书、掘金、github……Markdown 在很大程度上能提高你的码字效率和体验，如果你想快速编写格式丰富并且美观的文章，Markdown 是你的不二选择，怎么有一种打广告的感觉…… 兼容 HTML相信大家对超文本标记语言 HTML 都不陌生，那么 Markdown 和 HTML 有什么关系呢？简单来说就是，HTML 是一种发布的格式，而 Markdown 是一种书写的格式。什么意思呢，就是你在浏览器里边看到的所有东西都是由 HTML 标记组成的。那么 Markdown 想要显示对应的内容该怎么办呢，答案就是将其解析为 HTML 的形式来显示内容。 举一个例子，在 Markdown 语法中，有序列表使用数字接着一个英文句点来表示: 1231. Bird2. McHale3. Parish 上面的列表所产生的 HTML 标记为： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 上面的例子就是 Markdown 到 HTML 的转换。这个时候可能有的同学就会提问了，那如果我在 Markdown 里边插入 HTML 标签，这时候该怎么显示呢？这就是我想告诉大家的 Markdown 的一个特性兼容 HTML。Markdown 的格式语法只涵盖纯文本可以涵盖的范围。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown 只要直接加标签就可以了。要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。也就是说你如果在 Markdown 文档里添加了一个&lt;table&gt;标签，最后解析完成后，它仍然是一个&lt;table&gt;标签，不会解析错误，当然你如果想以代码段的形式呈现就是另外的情况了。 特殊字符自动转换在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;但你如果使用 Markdown，你就无需担心这些问题，它让你可以自然地书写字符，如果需要转换则全由它来处理。 Markdown 编辑器工欲善其事必先利其器，那么我们该用什么来编辑 Markdown 文档了？当然你用文本编辑器也是可以的…..现在支持 Markdown 语法编辑的有很多，每个人的习惯不同可能选择不同，只要自己用着顺手就行，这里我推荐几个比较热门的编辑器。 在线编辑器 Dillinger Dillinger 简洁却不失强大，同样支持支持 md, styled HTML, pdf 文件导出。 支持 dropbox, onedrive，google drive, github 存储。 Windows 平台编辑器 MarkdownPad MarkdownPad一款非常强大的 win 系统桌面端编辑器，支持实时预览，PDF 导出及导出格式自定义，公式编辑代码，桌面端使用最为广泛的 markown 编辑工具之一，推荐适用 pro 版，有破解版。 OS X 平台编辑器 Mou Mou 是 Mac 下杰出的 Markdown 编辑器，提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题，支持 CSS，HTML 和 PDF 导出等。 多平台编辑器 vscode 我现在一般使用 vscode 进行编辑，只需要安装Markdown Preview Enhanced插件，因为现在码代码基本都用 vscode，所以我用起来还是挺顺手的，强行安利一波。 下面再给大家提供一些 Markdown 编辑器参考网址，总能找到适合你的一款。 10 款流行的 Markdown 编辑器，总有一款适合你 Markdown 编辑器一览,总有一款适合你 Markdown 编辑器之比较 好用的 Markdown 编辑器一览 二、Markdown 语法介绍段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。空行的定义即是在显示上看起来像是空的，便会被视为空行。比如，若某一行只包含空格和制表符，那么该行不会显示任何东西，则该行也会被视为空行。 这里还需要注意的一点是，我们在写文章时，经常会习惯使用空格或制表符来缩进段落，但在 Markdown 语法里边普通段落是不能用空格或制表符来表示缩进的，即便加了也不会显示缩进。这是因为 Markdown 作为一种轻量级的文本编辑标记语言一开始只是为英文设计的，所以省去了缩进式的写法使书写更为简洁。那么如果我们一定要使用缩进呢？这里有四种方法可以实现。 在段落开头插入半角空格: &amp;ensp;或 &amp;#8194; 在段落开头插入全角空格: &amp;emsp;或 &amp;#8195; 在段落开头插入不换行空格: &amp;nbsp;或 &amp;#160; 如果是网页的话，最好使用样式表,将下段代码插入相应 css 即可。 123p &#123; text-indent: 2em; /*首行缩进*/&#125; 换行 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符） 在 Markdown 语法中，除了段落自动换行以外，我们可以通过插入换行符来使段落强制换行。这里需要注意的一点是 Markdown 语法中换行符的插入和其他大部分的 text-to-HTML 格式不一样。一般是点击回车即可换行，但在 Markdown 语法中必须在文字末尾输入 2 个及以上的空格，再点击回车才可实现换行。不过在一些编辑器中可以设置为回车换行，我使用的 Markdown Preview Enhanced 插件里默认的换行方式就是使用回车换行，当然你如果不习惯也可以更改设置。 空行刚开始使用 Markdown 语法时，我发现无论两个段落之间相距了多少行，在不做其他处理的情况下，最终显示时两个段落间的距离都只有一个空行。后来了解到 markdown 会把多余空行省略，这是它的成功之处之一，文章结构不靠空行来区分。但有时候我们需要添加空行来调整段落间的距离时，这个时候该怎么办呢？其实原理和实现缩进是一样的，这里有五种方法可以实现。 使用半角空格来代表空行: &amp;ensp;或 &amp;#8194; 使用全角空格来代表空行: &amp;emsp;或 &amp;#8195; 使用换行空格来代表空行: &amp;nbsp;或 &amp;#160; 直接插入换行符: &lt;br/&gt; 调整 markdown 的 css，改变 p 的 margin-bottom 属性，也可以实现段落间的距离的调整，不过这种方式是全局性的，可能不会每种情况都适用。 标题Markdown 支持两种标题的语法，类 Setext 形式 和类 Atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），任何数量的 = 和 - 都可以有效果。如下图: 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，这一种形式使用得相对多一些。这里需要注意一点就是在#和标题间最好隔一个空格，不然可能在有的编辑器下显示有问题，如下图: 区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。一共有两种方式，一种是在引用段落的每一行最前面加上&gt;，还有一种方式是只在引用段落的第一行最前面加上&gt;，这两种方式都能标记区块引用。 区块引用里还可以可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等 列表Markdown 支持有序列表和无序列表。 无序列表使用*、+或是-作为列表标记: 有序列表则使用数字接着一个英文句点,这里需要注意的一点是你在列表标记上使用的数字并不会影响最后输出的 HTML 结果，就是说 不管你写成这样 1231. 这是有序列表1. 这是有序列表1. 这是有序列表 还是这样 1233. 这是有序列表1. 这是有序列表8. 这是有序列表 最后的输出结果左边的列表标记都是根据第一行的标记数字往后顺序递增，不会顺序混乱，如图: 这里还需注意的是两个独立的有序列表间，如果中间没有其他的标记元素作为分隔，那么这两个有序列表则被视为一个有序列表来进行标记的顺序递增。 还需要注意几点的是 列表的项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符 项目列表很可能会不小心产生，比方说如果在行首出现数字-句点-空白的情况，则会产生项目列表。 11986. What a great season. 可以通过在句点前面加上反斜杠来避免 11986\. What a great season. 代码块作为一个程序猿，接触最多的自然是代码啦，那么在 Markdown 语法中该如何表示呢？简单说，插入代码可能的情况有以下两种: 只需要标记一小段行内代码，这种情况需要使用反引号 ` 把需要标记的代码给包起来。注意，如果你要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段。 需要标记一大段代码(即已经排版好的代码区块)，这里有两种方式来标记。 一种方式是通过简单的缩进 4 个空格或是 1 个制表符来标记。 123这是一个普通段落： 这是一个代码区块。 另一种 Fenced Code Block 方式是通过在第一行和最后一行添加三个反引号，中间的行为代码的形式来进行标记。在第一行的反引号加上代码类型，有助于代码在某些编辑器下的高亮显示。 123```&lt;代码块&gt;``` 分割线华丽的分割线该如何来显示呢？我们只需在一行内输入三个以上的*或-或_来建立分割线，并且这一行中不能够包含其他东西。恩..你如果想要在符号间加几个空格也是可以的，这样也可以建立分割线。 链接在写文章时，我们经常会插入一些链接。在 Markdown 语法中一共支持两种形式的链接语法: 行内式和参考式两种形式。 参考式的形式，采用一个方括号来标记链接文字，方括号后紧跟一个圆括号标记链接地址，如果还想要加上链接的 title 文字，只需要在链接地址后面隔一个空格，用双引号把 title 文字包起来即可。 1[链接文字](链接地址 &quot;title&quot;) 参考式的形式，采用一个方括号来标记链接文字，方括号后紧跟一个方括号来填入辨识链接地址的标记，然后你可以在文件的任意处将该标记的内容标记出来。我认为这种形式一方面是比较好读，增加链接而不让文章的阅读感觉被打断，另一方面也适用于在文章的不同位置需要使用相同的链接地址这种情况，这时只需要定义一次，然后就可以全局引用。 123[链接文字][链接标识][链接标识]: 链接地址 &quot;title&quot; (可在文件任何地方定义，title 内容，可以用单引号、双引号或是括弧包裹) 需要注意: 链接标识可以由字母、数字、空白和标点符号组成，但是并不区分大小写。 链接标识可以为空，此时链接变为隐式链接，这种情况下，链接标识会视为等同于链接文字，链接内容通过链接文字来定义。 123[链接文字][][链接文字]: 链接地址 &quot;title&quot; 还有一种链接方式是自动链接，Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 1&lt;https://www.baidu.com/?tn=90294326_hao_pg&gt; 强调在 Markdown 语法中，使用*和_来作为标记强调字词的符号。 被一个*或_包围的字词，最后显示的是斜体。 被两个*或_包围的字词，最后显示的是加粗体。 图片在 Markdown 语法中，图片的引入方法和链接的方法很相似，也有两种形式，行内式和参考式。唯一不同的是，图片映入时需要在第一个方括号前添上一个感叹号!,因为基本类似，这里就不继续详说了，详细语法可参考链接。 参考文献 Markdown 中文版语法说明 Markdown 编辑器之比较 好用的 Markdown 编辑器一览 怎样引导新手使用 Markdown？ Markdown——入门指南 写在最后总结了一下对 Markdown 的认识后，感觉自己对 Markdown 的理解又有了一些新的收获，注意到了一些以前忽视的东西。写一写总结感觉对自己帮助真的好大 :) ,希望我的总结也能够给你了解学习 Markdown 提供一点帮助，如果文章中出现错误或存在不严谨的地方，也请大家能够批评指出。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
