<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CavsZhouyou&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cavszhouyou.top/"/>
  <updated>2018-11-22T00:02:29.283Z</updated>
  <id>http://cavszhouyou.top/</id>
  
  <author>
    <name>CavsZhouyou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 WSL 和 Hyper 的 Windows 终端美化</title>
    <link href="http://cavszhouyou.top/%E5%9F%BA%E4%BA%8E-WSL-%E5%92%8C-Hyper-%E7%9A%84-Windows-%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96.html"/>
    <id>http://cavszhouyou.top/基于-WSL-和-Hyper-的-Windows-终端美化.html</id>
    <published>2018-11-21T23:54:11.000Z</published>
    <updated>2018-11-22T00:02:29.283Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="WSL" scheme="http://cavszhouyou.top/tags/WSL/"/>
    
      <category term="Hyper" scheme="http://cavszhouyou.top/tags/Hyper/"/>
    
      <category term="终端" scheme="http://cavszhouyou.top/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《习惯的力量》读书笔记</title>
    <link href="http://cavszhouyou.top/%E3%80%8A%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://cavszhouyou.top/《习惯的力量》读书笔记.html</id>
    <published>2018-10-15T23:53:29.000Z</published>
    <updated>2018-11-21T15:43:24.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu25-1.jpg" alt="《习惯的力量》读书笔记 配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文是我读完《习惯的力量》后，对书中内容所做的一些摘抄。书中有很多内容发人深省，为此想要记录下来，激励自己努力前行。希望这些内容也可以给你带来帮助，共勉！</p><a id="more"></a><h2 id="摘抄内容"><a href="#摘抄内容" class="headerlink" title="摘抄内容"></a>摘抄内容</h2><ol><li><p>成功的关键既在利用习惯，又超越习惯，战胜习惯。</p></li><li><p>自知之明是自我改善的开始。</p></li><li><p>如果将人的意志放置于一种特定的场合，加以磨练，那当然是一种“玉汝于成”之事。</p></li><li><p>要知道，在方向正确的前提下，成功者与不成功者的区别，往往在于能否坚持不断，能否坚持到底，所谓“水滴石穿”是也。</p></li><li><p>你非常需要仔细检查一遍自己的习惯。看看哪些是有益的，哪些是无益的，哪些是有害的，而后，将无益、有害的改为有益的。哪怕一个小小的改变，假以时日，必能受益无穷。</p></li><li><p>世界上有两种人：空想家和行动者。</p></li><li><p>甚至是教会的教义改革，以及国家的宪法改革，都比改掉我们身上哪怕最细小的坏习惯容易得多。</p></li><li><p>只有主动去改变潜意识，我们的生活才有可能发生改变，否者，我们只会继续那种我们以往一点一滴构筑起来的生活方式。</p></li><li><p>故事中的橡树是如此巨大，就像根深蒂固的习惯那样让人令人生畏，让人甚至惮与尝试改变它。</p></li><li><p>如果你希望出类拔萃，也希望生活方式与众不同，那么，你必须明白一点——是你的习惯决定着你的未来。</p></li><li><p>所有成功人士都有一个共性，那就是，基于良好习惯构成的日常行为规律。</p></li><li><p>不是天才和天赋造就了这些普通人士的非凡成就，而是坚韧不拔的好习惯，即不畏挫折与失败。并能在实践中不断地最求与完善。</p></li><li><p>这些自我强加的条条框框，最终演变成了阻碍你充分发挥潜能的习惯。</p></li><li><p>我们被锁链束缚，却从来不知道钥匙在自己手中。</p></li><li><p>生活总是把那些我们无法控制、更难以预料的事情强加于我们身上。</p></li><li><p>如何让上帝发笑，告诉他你的计划吧。</p></li><li><p>我们无法掌握发生在我们身上的所有事情。我们能控制的事情只有一件，那就是我们每天怎么做。我们可以去选择，每天，每月，或是每个时刻。<br>我们都在做出行动的选择。问题是，我们时常是选择“不去选择”。</p></li><li><p>我是谁？抓住我吧，训练我吧，对我严格管教吧，我将把整个世界呈现在你的脚下。千万别放纵我，那样，我会将你毁灭。我是谁？我就是习惯。</p></li><li><p>一个新的习惯就可以给我们完全陌生的惊喜。</p></li><li><p>每天都尝试去做一点你原本不喜欢的事吧，就当成是对自己的磨练。</p></li><li><p>为了成为一位行动者，一定要做到自律。</p></li><li><p>不论我做什么，也不论我多么努力，如果我不能做到掌握自己，那么僵永远不能发挥出自己最大的潜力。</p></li><li><p>克己自制</p></li><li><p>关键在于每天去做一点自己心里并不愿意做的事情，这样，你便不会为那些真正需要你完成的义务而感到痛苦，这就是养成自觉习惯的黄金定律。</p></li><li><p>自我控制并不单是一种非凡的美德它更是使其他美德焕发光彩的源泉。</p></li><li><p>掌握自己才能掌握一切。战胜自己才是最完美的胜利。</p></li><li><p>自制是世界上最大的量和财富。</p></li><li><p>我们对于自己的认知是如此惊人的无知….我们必须放弃自以为了解自己的这个念头，这将是人们最不现实的幻想。</p></li><li><p>一步一步的走，漫漫长路有尽头；一针一针的缝，褴褛之衫变天衣；一砖一瓦的垒，铜墙铁壁耸云霄；一片一片的积，万丈雪层深似山。</p></li><li><p>手中牢牢把握那根引导自己走完忙碌人生迷宫的线索的人，一定是那些每天早晨都会为一整天的事物做个计划并能按时完后计划的人。</p></li><li><p>如何度过每一天的早晨，正是我们自我检验控制能力的试剂。</p></li><li><p>懒惰的人哪，你要睡到几时呢？你何时睡醒呢？再睡片刻，打盹片刻，抱着手躺卧片刻，你的贫穷就必如强盗速来，你的匮乏仿佛拿兵器的人来到。</p></li><li><p>在改掉某个习惯，或是改变某种生活方式的目标的过程中，建立一种方法来跟踪自己的进步，将极大提高我们实现目标的成功概率。</p></li><li><p>让我们的显意识与潜意识沟通交流，再对它进行必要的训练，最后调整出它的新程序。</p></li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面的一些话，可能对于某些人来说，当做心灵鸡汤之类的话，看看就忘了。但我看完这本书之后之所以想把它们记录下来，是因为这本书给我了我一个警示，它告诉了我习惯对于我们的生活影响有多大。一个很小的坏习惯，你如果一年不改正，十年不改正，一生都不改正，那么你可能会因为这个很小的坏习惯错过多少东西，错过多少机会呢？我刚开始意识不到这有多严重，但当我假设如果我这一生都改不了这个坏习惯，那么它将要从现在一直伴随到我老去，直到我生命结束。我一想到这里，我就感到头皮发麻。这不是没有选择的呀！如果我们可以选择，那么我们为什么不选择一个好的习惯伴随我们一生呢？习惯的力量不仅仅只是它今天或者明天影响了你什么，它影响的是你以后的每一天，每一分钟，每一秒。它就像是我们身体的一部分，如何对待它，取决于我们自己。</p><p>如果有的选择，我为什么不选择做更好的自己！</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu25-1.jpg&quot; alt=&quot;《习惯的力量》读书笔记 配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本文是我读完《习惯的力量》后，对书中内容所做的一些摘抄。书中有很多内容发人深省，为此想要记录下来，激励自己努力前行。希望这些内容也可以给你带来帮助，共勉！&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://cavszhouyou.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="http://cavszhouyou.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书笔记" scheme="http://cavszhouyou.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之Bom对象详解</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BBom%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之Bom对象详解.html</id>
    <published>2018-08-13T15:05:36.000Z</published>
    <updated>2018-11-21T15:43:24.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu24-1.jpg" alt="JavaScript深入理解之Bom对象详解文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>当我们在 Web 中使用 JavaScript 的时候，BOM 对象——浏览器对象模型起着至关重要的作用。BOM 提供了很多对象，用于访问浏览器的功能。熟悉了解 BOM 对象对我们 WEB 开发有着重要的帮助，下面是我的一些理解和总结。</p><a id="more"></a><h2 id="BOM-对象定义"><a href="#BOM-对象定义" class="headerlink" title="BOM 对象定义"></a>BOM 对象定义</h2><p>BOM是指浏览器对象模型，它是对一系列在浏览器环境中使用对象的统称，这些对象提供了访问浏览器的功能。</p><p>在BOM对象中，window对象是最顶层对象，在浏览器环境中它是一个Global全局对象，其它对象（如：DOM对象）对是这个对象的属性（子对象）。BOM对象是与内容无关，主要用于管理浏览器窗口及窗口之间的通讯。下面是BOM对象的组成结构：</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu24-2.png" alt="配图24-2"></p><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>window 对象表示一个浏览器窗口或者一个 frame 框架，它处于对象层次的最顶端。在浏览器中 window 对象有双重角色。它既是通过 JavaScript 访问浏览器窗口的一个接口，提供处理浏览器窗口的方法和属性。又是 ECMAScript 中规定的 Global 对象，因此在全局作用域中声明的变量和函数都会成为 window 对象的属性和方法。</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><p>简单来说，Global 对象只是作为 window 对象的一部分来实现的，window 对象相对于 Global 对象扩展了处理浏览器窗口的方法和属性。</p><h2 id="DOM（document）相关对象"><a href="#DOM（document）相关对象" class="headerlink" title="DOM（document）相关对象"></a>DOM（document）相关对象</h2><p>DOM 可以认为是 BOM 的一个子集，DOM中文档操作相关对象，如：Node、Document、Element 等 DOM 节点类型对象，都是做为window对象的子属性出现的。</p><p>document 是 window 对象的了个属性，它是一个 Document 对象实例，表示当前窗口中文档对象。通过该对象，可以对文档和文档中元素、节点等进行操作。</p><h2 id="frames-对象"><a href="#frames-对象" class="headerlink" title="frames 对象"></a>frames 对象</h2><p>frames 对象是一个集合，表示当前页面中使用的子框架。如果页面中使用了框架，将产生一个框架集合 frames ，在集合中可以用数字下标（从0开始）或名字索引框架。集全中的每一个对象，包含了框架的页面布局信息，以及每一个框架所对应的 window 对象。</p><h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>navigator 是指浏览器对象，该对象提供了当前正在使用的浏览器的信息。navigator 对象中的属性是只读的，在 W3C 在HTML5 标准中，对该对象进行了规范。由于浏览器的同，该对象的具体值可能有所区别。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history 对象来保存浏览器历史记录信息，也就是用户访问的页面。浏览器的前进与后退功能本质上就是 history 的操作。history 对象记录了用户浏览过的页面，通过该对象提供的 API 可以实现与浏览器前进/后退类似的导航功能。</p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location是一个静态对象，该对象是对当前窗口URL地址的解析。该对象提供了可以访问URL中不同部分的信息属性，通过location对象也可以实现页面或锚点跳转等功能。</p><h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><p>screen对象中包含了用户显示器屏幕相关信息。通过该对象，可以访问用户显示器屏幕宽、高、色深等信息。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最近感觉总结一些东西的时候，没有抓住重点，很多时候时间都浪费在一些没有必要的知识点上。对于 BOM 的了解其实没必要太深入，其实主要是知道这个东西是什么，太细节的东西深究起来也没太大的必要。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu24-1.jpg&quot; alt=&quot;JavaScript深入理解之Bom对象详解文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;当我们在 Web 中使用 JavaScript 的时候，BOM 对象——浏览器对象模型起着至关重要的作用。BOM 提供了很多对象，用于访问浏览器的功能。熟悉了解 BOM 对象对我们 WEB 开发有着重要的帮助，下面是我的一些理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="Bom对象" scheme="http://cavszhouyou.top/tags/Bom%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之闭包</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之闭包.html</id>
    <published>2018-08-07T11:29:49.000Z</published>
    <updated>2018-11-21T15:43:24.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu22-1.jpg" alt="JavaScript深入理解之闭包文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>闭包一直是 JavaScript 中一个非常重要的概念。以前一直很难理解这个概念，主要是对 JavaScript 中的执行原理不熟悉。通过对前面执行上下文和垃圾收集的总结，终于可以对这个概念好好进行分析了。下面是我的一些理解和总结。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的最常见的方式，就是在一个函数内部创建另一个函数。</p><p>我们举一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>在 inner 函数中，我们可以通过作用域链访问到 a 变量，因此这就可以算是构成了一个闭包，因为 a 变量是其他函数作用域中的变量。</p><p>当然这和我们平时遇到的一些闭包问题可能不太一样，不过这些问题的实质其实都是在当前函数作用域中访问另一个函数作用域中的变量。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>下面我们来看一个经典的闭包的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = createFunctions();</span><br><span class="line"></span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 9 </span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 9 </span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 9 </span></span><br><span class="line">result[<span class="number">3</span>](); <span class="comment">// 9 </span></span><br><span class="line">result[<span class="number">4</span>](); <span class="comment">// 9 </span></span><br><span class="line">result[<span class="number">5</span>](); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>我们创建了一个函数用来创建一个函数数组，希望数组中的每个函数都打印自己的索引值，即位置0的函数打印0，位置1的函数打印1。但实际上最终每个函数打印的都是10，这是为什么呢？下面我们从程序执行开始分析。</p><h3 id="全局代码执行"><a href="#全局代码执行" class="headerlink" title="全局代码执行"></a>全局代码执行</h3><p>首先在执行全局代码之前， JavaScript 引擎会首先对全局代码进行解析，创建全局执行上下文 globalContext 。</p><ol><li><p>首先会创建全局执行上下文的第一个属性全局变量对象 globalVO 。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略全局对象其他属性</span></span><br><span class="line"></span><br><span class="line">globalContext.globalVO = &#123;</span><br><span class="line">    createFunctions: reference to <span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>,</span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>然后将 globalVO 压入全局上下文作用域链的顶端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globalContext.[[Scope]] = [ </span><br><span class="line">    globalContext.globalVO </span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>然后将全局上下文的作用域链赋值给 globalVO 中所有的函数的 <code>[[Scope]]</code> 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createFunctions.[[Scope]] = globalContext.[[Scope]];</span><br></pre></td></tr></table></figure></li></ol><p>全局执行上下文创建好后，进入到全局执行代码的执行阶段，首先将全局执行上下文压入执行上下文栈中，然后按顺序依次执行代码。</p><ol><li><p>在执行代码前判断得到全局执行上下文中的 this 指向 <code>globalVO</code>;</p></li><li><p>执行代码 <code>createFunctions();</code>进入createFunctions()函数执行阶段。</p></li></ol><h3 id="createFunctions-函数执行阶段"><a href="#createFunctions-函数执行阶段" class="headerlink" title="createFunctions() 函数执行阶段"></a>createFunctions() 函数执行阶段</h3><p>在执行 createFunctions() 函数前，Javascript 引擎会先对 createFunctions 函数代码进行解析，创建 createFunctions 函数的执行上下文 createFunctionsContext。</p><ol><li><p>创建 createFunctions 函数执行上下文的活动对象 createFunctionsAO。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createFunctionsContext.createFunctionsAO = &#123;</span><br><span class="line">    result: <span class="literal">undefined</span>,</span><br><span class="line">    i: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复制 createFunctions 函数的 <code>[[Scope]]</code> 属性，为函数执行上下文的作用域链赋值，然后将函数执行上下文的活动对象压入作用域链顶端。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createFunctionsContext.[[Scope]] = [</span><br><span class="line">    createFunctionsContext.createFunctionsAO,</span><br><span class="line">    globalContext.globalVO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ol><p>createFunctions 函数执行上下文创建后，进入函数代码的执行阶段，将 createFunctionsContext 压入执行上下文栈中，按顺序依次执行代码。</p><ol><li><p>在执行代码前，根据函数调用方式，判断得到 createFunctionsContext 的 this 指向为 <code>globalVO</code>。</p></li><li><p>执行第一行代码 <code>var result = new Array();</code> ，为 createFunctionsAO 的 result 属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createFunctionsContext.createFunctionsAO = &#123;</span><br><span class="line">    result: reference to <span class="built_in">Array</span> result,</span><br><span class="line">    i: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后执行 for 循环语句代码，执行第一次循环，i赋值为0，然后为每一个数组项创建一个函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createFunctionsContext.createFunctionsAO = &#123;</span><br><span class="line">    result: reference to <span class="built_in">Array</span> result,</span><br><span class="line">    i: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>循环代码执行完后，此时的 createFunctionsAO 为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createFunctionsContext.createFunctionsAO = &#123;</span><br><span class="line">    result: reference to <span class="built_in">Array</span> result,</span><br><span class="line">    i: <span class="number">9</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后执行代码<code>return result;</code>，返回函数数组。</p></li><li><p>createFunctions 函数的执行上下文弹栈，控制权交回全局执行上下文，接着执行代码 <code>result[0]();</code> ，进入 result[0] 函数的执行阶段。</p></li></ol><h3 id="result-0-函数执行阶段"><a href="#result-0-函数执行阶段" class="headerlink" title="result[0]函数执行阶段"></a>result[0]函数执行阶段</h3><p>在执行 result<a href="">0</a> 函数前，Javascript 引擎会先对 result[0] 函数代码进行解析，创建 result[0] 函数的执行上下文 result0Context。</p><ol><li><p>创建 result0 函数执行上下文的活动对象 result0AO。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result0Context.result0AO = &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复制 result0 函数的 <code>[[Scope]]</code> 属性，为函数执行上下文的作用域链赋值，然后将函数执行上下文的活动对象压入作用域链顶端。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result0Context.[[Scope]] = [</span><br><span class="line">    result0Context.result0AO,</span><br><span class="line">    createFunctionsContext.createFunctionsAO,</span><br><span class="line">    globalContext.globalVO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ol><p>result0 函数执行上下文创建后，进入函数代码的执行阶段，将 result0Context 压入执行上下文栈中，按顺序依次执行代码。</p><ol><li><p>在执行代码前，根据函数调用方式，判断得到 result0Context 的 this 指向为 <code>globalVO</code>。</p></li><li><p><strong>重点来了，执行代码 <code>console.log(i);</code> ，首先 Javascript 引擎会搜寻当前函数变量对象，当前函数的变量对象找不到 i 值时，会根据作用域链搜寻其他函数作用域中的变量，因此我们在 createFunctionsAO 中找到了 i 变量，此时的 i 变量保存的是 i 叠加后结果，因此函数打印的结果为 9。这里我们还需注意的一点是一般来说，在 createFunctions 函数执行完后 createFunctionsAO 就应该销毁了，但是由于我们在 result0Context 的作用域链中保留了对它的引用，因此在垃圾收集的时候，判断可以通过引用找到该对象，因此它就不会被清除掉，而是继续保留在内存中，让我们访问</strong>。</p></li><li><p>代码执行完成后，继续执行后面 result<a href="">1</a> 函数执行代码。</p></li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>那么我们如果想让这个函数符合我们的预期的话，我们应该怎么办呢？我们可以做一下这样的修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = createFunctions();</span><br><span class="line"></span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 0 </span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 1 </span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 2 </span></span><br><span class="line">result[<span class="number">3</span>](); <span class="comment">// 3 </span></span><br><span class="line">result[<span class="number">4</span>](); <span class="comment">// 4 </span></span><br><span class="line">result[<span class="number">5</span>](); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>相信通过上面的分析，大家应该能够明白这样写原因，这里就不再分析了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>闭包这个概念其实涉及到的知识点很过，如果执行上下文不熟悉，对垃圾收集机制不熟悉，理解起来其实是很模棱两可的。通过这样一个整体的分析，对闭包也有了一个更好的理解。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu22-1.jpg&quot; alt=&quot;JavaScript深入理解之闭包文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;闭包一直是 JavaScript 中一个非常重要的概念。以前一直很难理解这个概念，主要是对 JavaScript 中的执行原理不熟悉。通过对前面执行上下文和垃圾收集的总结，终于可以对这个概念好好进行分析了。下面是我的一些理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://cavszhouyou.top/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之垃圾收集</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之垃圾收集.html</id>
    <published>2018-08-07T06:57:13.000Z</published>
    <updated>2018-11-21T15:43:24.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu21-1.jpg" alt="JavaScript深入理解之垃圾收集 文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>JavaScript 具有自动垃圾收集机制，也就是说执行环境会负责管理代码执行过程中使用的内存。那么这种机制的具体实现原理是怎样的呢？下面是我的一些理解和总结。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JavaScript 垃圾收集机制的原理其实很简单,就是找出那些不再继续使用的变量,然后释放其占用的内存。为此垃圾收集会按照规定的时间间隔（或代码执行中预付的收集时间），周期性地执行这一操作。</p><p>但是该如何判断一个变量是否还有存在的必要呢？垃圾收集器必须跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>JavaScript 中最常用的垃圾收集方式是标记清除。它的具体工作步骤如下：</p><ol><li><p>给存储在内存中的所有变量加上标记（当然可以使用任何标记方式）</p></li><li><p>去掉当前执行环境中的变量，以及被执行环境中的变量引用的变量的标记</p></li><li><p>第二步结束后仍被标记的变量将被视为准备删除的变量，因为此时的执行环境中的变量已经无法访问到这些变量了。</p></li><li><p>完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></li></ol><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>下面我们来看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1();</span><br><span class="line"></span><br><span class="line">test2();</span><br></pre></td></tr></table></figure><p>假设当我们执行到test2()函数中<code>console.log(b);</code>语句时，垃圾收集器开始执行了，那么此时的内存占用情况是怎样的呢？请看下图</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu21-2.png" alt="配图21-2"></p><p><strong>上面仅列举了部分内存占用情况，只用作讲解标记清除的原理。</strong></p><ol><li><p>那我们首先开始第一步，将内存中的所有变量加上标记，这里以红色作为标记。</p><p> <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/petu21-2.png" alt="peitu21-2"></p></li><li><p>然后我们去掉当前执行环境中的变量，以及被执行环境中的变量引用的变量的标记。简单分析一下，此时执行环境中可以访问的变量有 d ,然后我们通过作用域链可以访问到全局变量对象，因此 a 和 b 我们也是可以访问到的，因此我们需要将这三个变量的标记去掉。</p><p> <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu21-3.png" alt="配图21-3"></p></li><li><p>此时只有 c 变量还保留有标记，说明 c 变量通过此时的环境已经访问不到了，所以 c 变量需要被清除掉来释放内存。</p></li><li><p>最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p><p> <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu21-4.png" alt="配图21-4"></p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p>标记清除法的第一个问题就是效率不高，因为在标记清除-阶段，整个程序将会等待，所有如果程序出现卡顿的情况你，那么就有可能是收集垃圾的情况。</p></li><li><p>标记清除法的第二个问题是，从上面的例子我们可以看出，在清除之后内存空间不是连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。与标记清除法相比，标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。</p></li></ol><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>因为标记清除法并不是 JavaScript 垃圾收集方法，很多其他语言也采用了这样的算法。这种算法的机制是这样的</p><blockquote><p>这个算法假定设置一个叫做根（root）的对象。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p></blockquote><p>我在网上看见有的人把根对象理解为了 JavaScript 中的全局对象。我认为这样去理解是解释不通的。因为在运行的某一时刻，垃圾收集收集器开始运行，通过全局对象是没有办法访问到整个引用链的。全局对象和其他对象间并不是一个树形的关联关系。</p><p>根据 JavaScript 高级程序设计中对标记清除的描述，我认为将这个跟对象理解为当前的执行上下文对象比较准确，因为通过当前的执行上下文对象可以访问到当前环境中的变量，也可以通过作用域链去访问到其他上下文中的活动对象，从而可以判断得到所有可以获得的对象和所有不能获得的对象。</p><p>当然这仅属于我个人的看法，欢迎大家交流指教。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>另一种不太常见的垃圾收集策略叫做引用计数，引用计数的含义就是跟踪记录每个值被引用的次数。</p><p>引用计数的原理是，当一个引用类型值被一个变量引用时，那么这个值的引用次数加一，如果该变量不再引用该值，则这个值的引用次数减一。当一个值的引用次数变为0的时候，就说明，没有变量引用该值，该值的内存空间可以被回收了。这样一来，当垃圾清除器下次运行时，它就会释放那些引用次数为0的值的内存。</p><p>如下面的例子所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;; <span class="comment">// 一个对象被创建，且 obj 引用了这个对象，因此该对象此时的引用次数为1，不能被清除</span></span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 此时，obj 不再引用该对象，则该对象的引用次数减为0，可以被清除</span></span><br></pre></td></tr></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>引用计数的最大问题就是循环引用的问题。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 中的引用。如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 一个对象 A 被创建，并被 obj1 引用，此时对象 A 的引用次数为1</span></span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 一个对象 B 被创建，并被 obj2 引用，此时对象 B 的引用次数为1</span></span><br><span class="line"></span><br><span class="line">    obj1.otherObject = obj2; <span class="comment">// 对象 B 又被 obj1.otherObject 引用，此时对象 B 的引用次数为2</span></span><br><span class="line">    obj2.otherObject = obj1; <span class="comment">// 对象 A 又被 obj2.otherObject 引用，此时对象 A 的引用次数为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为循环引用的问题，当函数执行完毕后对象 A 和对象 B 还将继续存在，因为它们的引用次数永远不会为0，这就意味着它们永远不会被回收，导致内存泄漏。</p><p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这篇文章只是对 JavaScript 垃圾收集的一个简单的总结。其中涉及到的很多都只是原理的理解，对于其细节的深入理解我认为没有太多必要。理解 JavaScript 垃圾收集机制对我们理解 JavaScript 中一些其他概念时也有很大的帮助。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu21-1.jpg&quot; alt=&quot;JavaScript深入理解之垃圾收集 文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;JavaScript 具有自动垃圾收集机制，也就是说执行环境会负责管理代码执行过程中使用的内存。那么这种机制的具体实现原理是怎样的呢？下面是我的一些理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="垃圾收集" scheme="http://cavszhouyou.top/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    
      <category term="标记清除" scheme="http://cavszhouyou.top/tags/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4/"/>
    
      <category term="引用计数" scheme="http://cavszhouyou.top/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之继承</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之继承.html</id>
    <published>2018-08-04T12:13:51.000Z</published>
    <updated>2018-11-21T15:43:24.973Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu20-1.jpg" alt="JavaScript深入理解之继承"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>继承是面向对象语言中最重要的一个概念。许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法和签名，而实现继承则继承实际的方法。由于在 JavaScript 中函数没有签名，因此无法实现接口继承，只支持实现继承。</p><a id="more"></a><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在 ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。这一部分已经在前面总结过了，就不再多说了。</p><p>缺点：</p><ol><li><p>包含引用类型的原型属性会被所有实例属性共享，容易造成属性的修改混乱。</p></li><li><p>在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p></li></ol><p>基于以上问题，在实践中很少会单独使用原型链。</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>借用构造函数的思想主要是在子类型的构造函数中调用超类型构造函数。如下面的例子所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承了 SuperType</span></span><br><span class="line"></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure><p>优点：可以在子类型构造函数中向超类型构造函数添加参数</p><p>缺点：和构造函数模式一样的问题，所有的方法都在构造函数中定义，因此就无法做到函数的复用。而且超类型的原型中定义的方法，对于子类型而言也是不可见的。</p><p>基于以上问题，借用构造函数的技术也是很少单独使用的。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。这种方法的主要思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"james"</span>,<span class="number">9</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">// "james"</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"kobe"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">// "kobe"</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>优点：组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof 和 isPropertyOf() 也能够用于识别基于组合继承创建的对象。</p><p>缺点：调用了两次超类的构造函数，导致基类的原型对象中增添了不必要的超类的实例对象中的所有属性。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承的主要思路是可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。如下面的例子所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说这个函数的作用就是，传入一个对象，返回一个原型对象为该对象的新对象。</p><p>ECMAScript 5中新增了 Object.create() 方法规范了原型式继承。这个方法接收两个参数，一个是将被用作新对象原型的对象，一个是为新对象定义额外属性的对象（可选）。</p><p>注意第二个参数的格式与 Object.defineProperties() 方法的第二个参数格式相同。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。在第二个参数为空的情况下，该方法与 object() 方法的行为相同。</p><p>优点：可以实现基于一个对象的简单继承，不必创建构造函数</p><p>缺点：与原型链中提到的缺点相同，一个是传参的问题，一个是属性共享的问题。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承的思路是，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回这个对象。如下面的例子所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    </span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 某种方式增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;  <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"james"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line"></span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure><p>优点： 在主要考虑对象而不是自定义类型和构造函数的情况下，实现简单的继承。</p><p>缺点：使用该继承方式，在为对象添加函数的时候，没有办法做到函数的复用。</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>前面我们提到过了组合继承的缺点，由于调用了两次超类的构造函数，导致基类的原型对象中增添了不必要的超类的实例对象中的所有属性。</p><p>寄生式组合继承就是用来解决这个问题，它与组合继承不同的地方主要是，在继承原型时，我们继承的不是超类的实例对象，而是原型对象是超类原型对象的一个实例对象，这样就解决了基类的原型对象中增添了不必要的超类的实例对象中的所有属性d的问题。</p><p>我们可以封装继承原型时函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">// 创建原型对象是超类原型对象的一个实例对象</span></span><br><span class="line">  </span><br><span class="line">    prototype.constructor = subType; <span class="comment">// 弥补因为重写原型而失去的默认的 constructor 属性。</span></span><br><span class="line"> </span><br><span class="line">    subType.prototype = prototype; <span class="comment">// 实现原型继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：效率高，避免了在 SubType.prototype 上创建不必要的属性。与此同时还能保持原型链不变，开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于继承相关的知识就总结到这里，感觉总结一遍对每种继承方式的理解就更深刻了一些，加油！</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu20-1.jpg&quot; alt=&quot;JavaScript深入理解之继承&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;继承是面向对象语言中最重要的一个概念。许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法和签名，而实现继承则继承实际的方法。由于在 JavaScript 中函数没有签名，因此无法实现接口继承，只支持实现继承。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="继承" scheme="http://cavszhouyou.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之对象创建</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之对象创建.html</id>
    <published>2018-08-04T03:00:36.000Z</published>
    <updated>2018-11-21T15:43:24.889Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu19-1.jpg" alt="JavaScript深入理解之对象创建文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在 JavaScript 中虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但是这些方法都有一个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这些问题，人们提出了很多对象创建的解决办法，下面是我对 JavaScript 对象创建的一些理解和总结。</p><a id="more"></a><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽离了创建对象的具体过程。考虑到在 ECMAScript 中无法创建类，开发人员发明以一种函数，用函数来封装以特定接口创建对象的细节。如下面的例子所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"james"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"kobe"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>优点：解决了创建多个相似对象时，代码的复用问题</p><p>缺点：使用工厂模式创建的对象，没有解决对象识别的问题（就是怎样知道一个对象的类型是什么）</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>前面我们提到过，ECMAScript 中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外我们也可以创建自定义的构造函数，从而定义对象类型的属性和方法。我们使用构造函数的方法可以将前面的例子重写如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> createPerson(<span class="string">"james"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> createPerson(<span class="string">"kobe"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>当我们使用构造函数实例化一个对象的时候，对象中会包含一个 __proto__ 属性指向构造函数原型对象，而原型对象中则包含一个 constructor 属性指向构造函数。因此在实例对象中我们可以通过原型链来访问到 constructor 属性，从而判断对象的类型。</p><p>优点：解决了工厂模式中对象类型无法识别的问题，并且创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。</p><p>缺点：我们知道 ECMAScript 中的函数是对象，在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>我们知道，我们创建的每一个函数都有一个 prototype 属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。我们通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码的复用问题。如下面所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"james"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">9</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"student"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// "james"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// "james"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>与构造函数模式不同的是，原型对象上的属性和方法是有所有实例所共享的。也就是说，上面 person1 和 person2 访问的都是同一组属性和同一个 sayName() 函数。</p><p>优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。</p><p>缺点：</p><ol><li><p>首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。</p></li><li><p>因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。</p></li></ol><h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。使用这种模式的好处就是，每个实例都会拥有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。而且这中混成模式还支持向构造函数传递参数，可以说是及两种模式之长。</p><p>下面我们通过这种方法来重写一下上面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> createPerson(<span class="string">"james"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> createPerson(<span class="string">"kobe"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// "james"</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// "kobe"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。</p><p>缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>由于上面混成模式存在封装性的问题，动态原型模式是解决这个问题的一个方案。这个方法把所有信息都封装到了构造函数中，而在构造函数中通过判断只初始化一次原型。下面我们来看一下例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">"function"</span> )&#123;</span><br><span class="line"></span><br><span class="line">        Person.prototype.sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> createPerson(<span class="string">"james"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// "james"</span></span><br></pre></td></tr></table></figure><p>注意在 if 语句中检查的可以是初始化后应该存在的任何属性或方法，不必要检查每一个方法和属性，只需要检查一个就行。</p><p>优点：解决了混成模式中封装性的问题</p><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>如果在前面几种模式不适用的情况下，可以使用寄生构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"james"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以发现，其实这个模式和工厂模式基本上是一摸一样的，只不过我们是采用 new 操作符最后来创建对象。</p><p>注意在构造函数不返回值的情况下，默认会返回新创建的对象，而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。</p><p>优点：我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。</p><p>缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。</p><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>Douglas Crockford 发明了 JavaScript 中的稳妥对象这个概念。所谓稳妥对象，指的就是，没有公共属性，而且其方法也不使用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用。</p><p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用 this ；二是不使用 new 操作符调用构造函数。因此我们可以将前面的例子改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  Person(<span class="string">"james"</span>，<span class="number">9</span>，<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">// "james"</span></span><br></pre></td></tr></table></figure><p>优点：以上面为例，除了 sayName 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。</p><p>缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>简单总结了一下对象的创建方式，感觉收获很多，理解了每一种模式的优缺点后，以后才能更好的去应用。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu19-1.jpg&quot; alt=&quot;JavaScript深入理解之对象创建文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在 JavaScript 中虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但是这些方法都有一个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这些问题，人们提出了很多对象创建的解决办法，下面是我对 JavaScript 对象创建的一些理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="对象创建" scheme="http://cavszhouyou.top/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    
      <category term="构造函数" scheme="http://cavszhouyou.top/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="new" scheme="http://cavszhouyou.top/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之原型与原型链</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之原型与原型链.html</id>
    <published>2018-08-03T03:26:04.000Z</published>
    <updated>2018-11-21T15:43:24.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-1.jpg" alt="JavaScript深入理解之原型与原型链文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>原型和原型链一直都是 JavaScript 中很重要的概念，理解它们有助于我们理解预定义引用类型间的关系以及 JavaScript 中对象继承的实现机制，下面是我对原型和原型链的理解和总结。</p><a id="more"></a><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型对象理解"><a href="#原型对象理解" class="headerlink" title="原型对象理解"></a>原型对象理解</h3><h4 id="prototype-属性"><a href="#prototype-属性" class="headerlink" title="prototype 属性"></a>prototype 属性</h4><p>我们创建的每一个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象。这个对象就是函数的原型对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为原型对象添加方法</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数也是对象，下面我们来看一下函数对象和它的原型对象之间的关系。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-2.png" alt="配图18-2"></p><h4 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h4><p>当函数创建，prototype 属性指向函数的原型对象时，在默认情况下，其原型对象将会获得一个 constructor 属性，这个属性是一个指针，指向 prototype 所在的函数对象。</p><p>拿前面的一个例子来说 Person.prototype.constructor 就指向 Person 函数对象。</p><p>下面我们来更新一下它们之间的关系图。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-3.png" alt="配图18-3"></p><h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>当我们调用构造函数创建一个新实例后，在这个实例的内部将包含一个指针，指向构造函数的原型对象，在 ECMA-262 第五版中管这个指针叫做[[Prototype]]。</p><p>需要注意的是在脚本中没有标准的方式访问[[Prototype]]，但是在 Firefox，Safari 和 Chrome 中每个对象中都支持一个属性 __proto__ 来访问，为了区分 prototype 属性，我们在下边都使用 __proto__来表示。</p><p>根据前面的 Person 构造函数我们新建一个实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(student.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从上面我们可以看出，这个连接是存在与实例与构造函数的原型对象之间的，而不是存在于实例和构造函数之间的。</p><p>下面我们来看一下现在这几个对象之间的关系</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-5.png" alt="配图18-5"></p><h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h4><p>虽然我们在脚本中没有办法访问到[[Prototype]]属性，但是我们可以通过 isPrototypeOf 方法来确定对象之间时候存在这种关系。</p><p>如果一个对象的[[prototype]]属性指向调用 isPrototyeOf() 方法的对象时，这个方法就返回ture，我们那上面的例子举例来说</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(student)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>在 ECMAScript 5 中新增了一个方法叫 Object.getPrototypeOf() ，这个方法可以返回[[Prototype]]的值，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(student) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><p>每当代码读取对象的某个属性时，首先会在对象本身搜索这个属性，如果找到该属性就返回该属性的值，如果没有找到，则继续搜索该对象对应的原型对象，以此类推下去。</p><p>因为这样的搜索过程，因此我们如果在实例中添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，因为在实例中搜索到该属性后就不会再向后搜索了。</p><h4 id="属性判断"><a href="#属性判断" class="headerlink" title="属性判断"></a>属性判断</h4><p>既然一个属性既可能是实例本身的，也有可能是其原型对象的，那么我们该如何来判断呢？</p><p>在属性确认存在的情况下，我们可以使用 hasOwnProperty() 方法来判断一个属性是存在与实例中，还是存在于原型中。注意这个方法只有在给定属性存在于实例中时，才会返回 true 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> = </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"laker"</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(student.name); <span class="comment">// laker</span></span><br><span class="line"><span class="built_in">console</span>.log(student.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student.name = <span class="string">"xiaoming"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(student.name); <span class="comment">//xiaoming 屏蔽了原型对象中的 name 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(student.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面主要是针对属性确认存在的情况下，如果这个属性不一定存在的话，这样判断就不够准确，因此我们需要首先判断这个属性是否存在，然后再进行上面的判断操作。</p><p>判断一个属性是否存在，我们可以使用 in 操作符，它会在对象能够访问给定属性时返回 true，无论该属性存在于实例还是原型中。</p><p>因此我们可以封装这样一个函数，来判断一个属性是否存在于原型中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h4><p>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中包括了存在于实例中的属性，也包括了存在于原型中的属性。</p><p>需要注意的一点是，屏蔽了实例中不可枚举属性的实例属性也会在 for-in 循环中返回。</p><h4 id="所有属性获取"><a href="#所有属性获取" class="headerlink" title="所有属性获取"></a>所有属性获取</h4><p>如果想要获得对象上所有可枚举的实例属性，可以使用 Object.keys() 方法，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p><p>如果想要获取所有的实例属性，无论它是否可以枚举，我们可以使用 Object.getOwnPropertyNames() 方法。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="原型链理解"><a href="#原型链理解" class="headerlink" title="原型链理解"></a>原型链理解</h3><p>ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用的一个引用类型继承另一个引用类型的属性和方法。</p><p>原型链的主要实现方法是让构造函数的原型对象等于另一个类型的实例，此时的原型对象因为是实例，因此将包含一个指向另一个原型的指针，相应地另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与类型的链条。这就是原型链的基本概念。</p><p>下面我们来看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Middle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Middle.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Middle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> suber = <span class="keyword">new</span> Sub();</span><br></pre></td></tr></table></figure><p>下面我们来看看这几个对象间的关系</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-7.png" alt="配图18-7"></p><h3 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h3><p>其实我们上面这个原型链是不完整的，还记得我们以前说过所有的引用类型都继承了 Object 吗？这个继承就是通过原型链来实现的。我们一定要记住，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.Prototype 。这也正是所有的自定义类型都会继承 toString() 、valueOf() 等默认方法的根本原因。</p><p>那么我更新一下我们上面的原型链</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-8.png" alt="配图18-8"></p><p>Object.prototype 就是原型链的终点了，我们可以试着打印一下 Object.prototype.__proto__，我们会发现返回的是一个 null 空对象，这就意味着原型链的结束。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>总结了原型和原型链的知识后，感觉对 JavaScript 语言的理解更加深刻了，也为后面理解对象的创建和继承打下了基础。其实理解原型链，对于 JavaScript 中一些预定义类型的行为和实现就很好理解了。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu18-1.jpg&quot; alt=&quot;JavaScript深入理解之原型与原型链文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;原型和原型链一直都是 JavaScript 中很重要的概念，理解它们有助于我们理解预定义引用类型间的关系以及 JavaScript 中对象继承的实现机制，下面是我对原型和原型链的理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="原型" scheme="http://cavszhouyou.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://cavszhouyou.top/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之引用类型详解</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之引用类型详解.html</id>
    <published>2018-08-02T10:41:49.000Z</published>
    <updated>2018-11-21T15:43:24.973Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu17-1.jpg" alt="JavaScript深入理解之引用类型详解文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>相信提到 JavaScript 中的引用类型大家都不陌生，但是对于什么是引用类型这个问题，我一直充满疑惑，对这个概念的理解不是很清晰。引用类型与类的概念有什么不同？引用类型的实现机制到底是什么？下面是我对引用类型的一些理解和总结。</p><a id="more"></a><h2 id="引用类型定义"><a href="#引用类型定义" class="headerlink" title="引用类型定义"></a>引用类型定义</h2><p>引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><p><strong>简单来理解，引用类型在逻辑上等价于其他面向对象语言中的类的概念。</strong></p><h2 id="预定义引用类型"><a href="#预定义引用类型" class="headerlink" title="预定义引用类型"></a>预定义引用类型</h2><p>JavaScript 提供了一些预定义的引用类型，用于创建相应引用类型的对象。如 Object 类型 、 Array 类型 、 Date 类型、 RegExp 类型、 Function 类型、 Boolean 基本包装类型、 String 基本包装类型、 Number 基本包装类型等。  </p><h2 id="引用类型的结构"><a href="#引用类型的结构" class="headerlink" title="引用类型的结构"></a>引用类型的结构</h2><p>在上面我们了解到引用类型是一种数据结构，那这种数据结构是如何定义的呢？前面我们知道了引用类型在逻辑上其实等价于其他面向对象语言中的类的概念，那么它的作用与类肯定也是相似的。</p><p>在 JavaScript 语言中对象是某个特定引用类型的实例。新对象是使用 new 操作符后跟一个 <strong>构造函数</strong> 来创建的。注意构造函数与一般的函数没有区别，只不过该函数是出于创建新对象的目的而定义的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> laker = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>因此我们可以看出，<strong>引用类型的定义其实就是其对应的构造函数的定义</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台测试一下看看</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>) <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>) <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p>我们知道无论在什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象，原型对象可以使所有对象实例共享它所包含的属性和方法。</p><p>同样的，<strong>引用类型对应的构造函数也拥有原型对象</strong>，在这个原型对象中保存了该引用类型预定义的方法，如 Array 类型中的 concat 、 every方法等。</p><p>关于原型这一块的内容会在以后详细讲解。</p><h2 id="引用类型的值"><a href="#引用类型的值" class="headerlink" title="引用类型的值"></a>引用类型的值</h2><p>引用类型的值是引用类型的一个实例，也就是 JavaScript 中常说的对象。每一个对象都是其对应引用类型的实例，对象是使用 new 操作符后跟一个 <strong>构造函数</strong> 来创建的。</p><p>我们知道构造函数和普通函数其实没有区别，只是因为由 new 操作符来调用才被称为构造函数，那么使用 new 操作符来创建一个对象的过程到底是怎样的呢？下面让我们来看一下具体的步骤：</p><ol><li>首先创建一个新的对象</li><li>然后将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li><li>执行构造函数的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。因此该实例可以通过原型链访问到原型对象中的方法及属性。</p><h2 id="预定义引用类型间的关系"><a href="#预定义引用类型间的关系" class="headerlink" title="预定义引用类型间的关系"></a>预定义引用类型间的关系</h2><p>在所有预定义引用类型中，Object 是特殊的一个数据类型。因为它是最基础的类型，其他的所有类型都都从 Object 继承了基本的行为。这种继承的方式是以原型链的方式实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台测试一下看看</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure><p>在后面原型链的总结中我还会详细解释一部分，在这里我们只需要记住，Object 是最基础的类型，其他的所有类型都从 Object 继承了基本的行为。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于引用类型的理解每个人可能都有不同，主要是 JavaScript 的实现机制和一般的面向对象语言有所不同，所以理解起来有些困难。深入理解引用类型的概念对理解 JavaScript 的面向对象实现机制很有帮助。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu17-1.jpg&quot; alt=&quot;JavaScript深入理解之引用类型详解文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;相信提到 JavaScript 中的引用类型大家都不陌生，但是对于什么是引用类型这个问题，我一直充满疑惑，对这个概念的理解不是很清晰。引用类型与类的概念有什么不同？引用类型的实现机制到底是什么？下面是我对引用类型的一些理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="原型链" scheme="http://cavszhouyou.top/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="构造函数" scheme="http://cavszhouyou.top/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="new" scheme="http://cavszhouyou.top/tags/new/"/>
    
      <category term="引用类型" scheme="http://cavszhouyou.top/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Vue历险记之可输入下拉框的实现</title>
    <link href="http://cavszhouyou.top/Vue%E5%8E%86%E9%99%A9%E8%AE%B0%E4%B9%8B%E5%8F%AF%E8%BE%93%E5%85%A5%E4%B8%8B%E6%8B%89%E6%A1%86%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://cavszhouyou.top/Vue历险记之可输入下拉框的实现.html</id>
    <published>2018-06-12T14:24:53.000Z</published>
    <updated>2018-11-21T15:43:25.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu16-1.jpg" alt="Vue历险记之可输入下拉框的实现 文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近在做项目时，遇到了一个奇怪的需求，简单来说就是在下拉框选择后，可以对选中项的文本进行修改，选项文本和用户的输入之间属于双向绑定的关系。以前没有遇到过这种需求….在尝试了几种方法后，总算把这个问题解决了，下面简单谈一下我的方法。</p><a id="more"></a><h2 id="Demo地址"><a href="#Demo地址" class="headerlink" title="Demo地址"></a>Demo地址</h2><p><a href="http://cavszhouyou.top/Demo-Display/inputSelectBoxDemoDisplay.html">可输入拉框demo地址</a></p><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>我刚开始的想法是能不能直接在每个 option 里边嵌套一个 input 标签,然后把每个 input 的 value 值与 option 的文本值进行绑定，实践后这种方法行不通。</p><p>我现在的方法是使用一个 input 标签来动态获取 select 框当前选项的文本值，然后当 input 输入时，动态修改对应 option 的文本值，以此来实现双向绑定的功能。</p><p>因为我们使用的分别是 input 和 select ，因此我们需要对这两个标签进行一些样式的修改以此来让它们看着就像是一个可输入的 select 框。主要是调整 input 的位置，使其覆盖住 select 框中原本文本的位置，然后设置 input 隐藏掉右边的边框。因为它们的数据是双向绑定的，因此这样看起来就是一个可输入的下拉框。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 7]&gt;      &lt;html class="no-js lt-ie9 lt-ie8 lt-ie7"&gt; &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 7]&gt;         &lt;html class="no-js lt-ie9 lt-ie8"&gt; &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 8]&gt;         &lt;html class="no-js lt-ie9"&gt; &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gt IE 8]&gt;&lt;!--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">"no-js"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>可输入下拉框demo展示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"可输入下拉框demo展示"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="undefined">            position: absolute;</span></span><br><span class="line"><span class="undefined">            top: 200px;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">            margin: 0 auto;</span></span><br><span class="line"><span class="undefined">            width: 600px;</span></span><br><span class="line"><span class="undefined">            height: 300px;</span></span><br><span class="line"><span class="undefined">            text-align: center;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.select-box</span> &#123;</span></span><br><span class="line"><span class="undefined">            width: 300px;</span></span><br><span class="line"><span class="undefined">            height: 50px;</span></span><br><span class="line"><span class="undefined">            padding-left: 20px;</span></span><br><span class="line"><span class="undefined">            font-size: 18px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-box</span> &#123;</span></span><br><span class="line"><span class="undefined">            position: absolute;</span></span><br><span class="line"><span class="undefined">            margin-left: -300px;</span></span><br><span class="line"><span class="undefined">            box-sizing: border-box;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#9e9e9e</span>;</span></span><br><span class="line"><span class="undefined">            border-right: none;</span></span><br><span class="line"><span class="undefined">            width: 280px;</span></span><br><span class="line"><span class="undefined">            height: 50px;</span></span><br><span class="line"><span class="undefined">            padding-left: 23px;</span></span><br><span class="line"><span class="undefined">            font-size: 18px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 7]&gt;</span></span><br><span class="line"><span class="comment">            &lt;p class="browsehappy"&gt;You are using an &lt;strong&gt;outdated&lt;/strong&gt; browser. Please &lt;a href="#"&gt;upgrade your browser&lt;/a&gt; to improve your experience.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        &lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>可输入下拉框<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"select-box"</span> <span class="attr">v-model</span>=<span class="string">"selectValue"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in options"</span> <span class="attr">:key</span>=<span class="string">"index"</span> <span class="attr">:value</span>=<span class="string">"item.value"</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"input-box"</span> <span class="attr">ref</span>=<span class="string">"inputBox"</span> <span class="attr">:value</span>=<span class="string">"inputValue"</span> @<span class="attr">input</span>=<span class="string">"changeValue()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> container = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#container'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="undefined">                selectValue: 1000,</span></span><br><span class="line"><span class="undefined">                options: [&#123;</span></span><br><span class="line"><span class="undefined">                    value: 1000,</span></span><br><span class="line"><span class="javascript">                    text: <span class="string">"骑士总冠军"</span></span></span><br><span class="line"><span class="undefined">                &#125;, &#123;</span></span><br><span class="line"><span class="undefined">                    value: 2000,</span></span><br><span class="line"><span class="javascript">                    text: <span class="string">"湖人总冠军"</span></span></span><br><span class="line"><span class="undefined">                &#125;, &#123;</span></span><br><span class="line"><span class="undefined">                    value: 3000,</span></span><br><span class="line"><span class="javascript">                    text: <span class="string">"火箭总冠军"</span></span></span><br><span class="line"><span class="undefined">                &#125;, &#123;</span></span><br><span class="line"><span class="undefined">                    value: 4000,</span></span><br><span class="line"><span class="javascript">                    text: <span class="string">"马刺总冠军"</span></span></span><br><span class="line"><span class="undefined">                &#125;]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            computed: &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取select框中所选文本值</span></span></span><br><span class="line"><span class="javascript">                inputValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> value;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//遍历找到对应文本值</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.options.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (item.value === self.selectValue) &#123;</span></span><br><span class="line"><span class="undefined">                            value = item.text;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> value;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                <span class="comment">// input输入修改options中的对应数值</span></span></span><br><span class="line"><span class="javascript">                changeValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> text = <span class="keyword">this</span>.$refs.inputBox.value;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//遍历修改对应文本值</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.options.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (item.value === self.selectValue) &#123;</span></span><br><span class="line"><span class="undefined">                            item.text = text;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这是我暂时想到的解决办法，以前没有遇到过这样的问题，实现的过程还是挺有趣的，以后有时间再看看能不能再完善一些。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu16-1.jpg&quot; alt=&quot;Vue历险记之可输入下拉框的实现 文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近在做项目时，遇到了一个奇怪的需求，简单来说就是在下拉框选择后，可以对选中项的文本进行修改，选项文本和用户的输入之间属于双向绑定的关系。以前没有遇到过这种需求….在尝试了几种方法后，总算把这个问题解决了，下面简单谈一下我的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="Vue历险记" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/Vue%E5%8E%86%E9%99%A9%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://cavszhouyou.top/tags/vue/"/>
    
      <category term="select下拉框" scheme="http://cavszhouyou.top/tags/select%E4%B8%8B%E6%8B%89%E6%A1%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之执行上下文示例分析</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之执行上下文示例分析.html</id>
    <published>2018-04-23T09:34:39.000Z</published>
    <updated>2018-11-21T15:43:25.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu15-1.jpg" alt="JavaScript深入理解之执行上下文示例分析 文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前面已经对执行上下文的创建及其三个属性做了总结，本篇文章通过一个示例分析来将前面的总结的知识点做一个串联与回顾。不了解执行上下文的同学可以先看我前面的几篇对执行上下文的总结。</p><a id="more"></a><h2 id="讲解示例"><a href="#讲解示例" class="headerlink" title="讲解示例"></a>讲解示例</h2><p>我们先来看一看下边这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"global var"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"var in outerFunc"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">"var in innerFunc"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    innerFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunc();</span><br></pre></td></tr></table></figure><p>执行这段代码，我们很容易判断得到如下结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">in</span> outerFunc</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">in</span> innerFunc</span><br><span class="line">global <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>下面我们来分析一下这段代码的执行过程。</p><h2 id="执行分析"><a href="#执行分析" class="headerlink" title="执行分析"></a>执行分析</h2><h3 id="全局代码执行"><a href="#全局代码执行" class="headerlink" title="全局代码执行"></a>全局代码执行</h3><p>首先在执行全局代码之前， JavaScript 引擎会首先对全局代码进行解析，创建全局执行上下文 globalContext 。</p><ol><li><p>首先会创建全局执行上下文的第一个属性全局变量对象 globalVO 。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略全局对象其他属性</span></span><br><span class="line"></span><br><span class="line">globalContext.globalVO = &#123;</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    foo: reference to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>,</span></span><br><span class="line"><span class="function">    <span class="title">outerFunc</span>: <span class="title">reference</span> <span class="title">to</span> <span class="title">function</span> <span class="title">outerFunc</span></span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>然后将 globalVO 压入全局上下文作用域链的顶端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globalContext.[[Scope]] = [ </span><br><span class="line">    globalContext.globalVO </span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>然后将全局上下文的作用域链赋值给 globalVO 中所有的函数的 <code>[[Scope]]</code> 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.[[Scope]] = globalContext.[[Scope]];</span><br><span class="line"></span><br><span class="line">outerFunc.[[Scope]] = globalContext.[[Scope]];</span><br></pre></td></tr></table></figure></li></ol><p>全局执行上下文创建好后，进入到全局执行代码的执行阶段，首先将全局执行上下文压入执行上下文栈中，然后按顺序依次执行代码。</p><ol><li><p>在执行代码前判断得到全局执行上下文中的 this 指向 <code>globalVO</code>;</p></li><li><p>执行第一行代码 <code>var a = &quot;global var&quot;;</code> ,为 globalVO 中的 a 属性赋值为 <code>&quot;global var&quot;</code>;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> globalContext.globalVO = &#123;</span><br><span class="line">    a: <span class="string">"global var"</span>,</span><br><span class="line">    foo: reference to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>,</span></span><br><span class="line"><span class="function">    <span class="title">outerFunc</span>: <span class="title">reference</span> <span class="title">to</span> <span class="title">function</span> <span class="title">outerFunc</span></span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>执行代码 <code>outerFunc();</code>，进入outerFunc()函数执行阶段。</p></li></ol><h3 id="outerFunc-函数执行阶段"><a href="#outerFunc-函数执行阶段" class="headerlink" title="outerFunc() 函数执行阶段"></a>outerFunc() 函数执行阶段</h3><p>在执行 outerFunc() 函数前，Javascript 引擎会先对 outerFunc 函数代码进行解析，创建 outerFunc 函数的执行上下文 outerFuncContext。</p><ol><li><p>创建 outerFunc 函数执行上下文的活动对象 outerFuncAO。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outerFuncContext.outerFuncAO = &#123;</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    innerFunc: reference to <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span></span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>复制 outerFunc 函数的 <code>[[Scope]]</code> 属性，为函数执行上下文的作用域链赋值，然后将函数执行上下文的活动对象压入作用域链顶端。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outerFuncContext.[[Scope]] = [</span><br><span class="line">    outerFuncContext.outerFuncAO,</span><br><span class="line">    globalContext.globalVO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>然后将作用域链赋值给 outerFuncAO 中所有函数的 <code>[[Scope]]</code> 属性。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innerFunc.[[Scope]] = outerFuncContext.[[Scope]];</span><br></pre></td></tr></table></figure></li></ol><p>outerFunc 函数执行上下文创建后，进入函数代码的执行阶段，将 outerFuncContext 压入执行上下文栈中，按顺序依次执行代码。</p><ol><li><p>在执行代码前，根据函数调用方式，判断得到 outerFuncContext 的 this 指向为 <code>globalVO</code>。</p></li><li><p>执行第一行代码 <code>var b = &quot;var in outerFunc&quot;;</code> ，为 outerFuncAO 的 b 属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outerFuncContext.outerFuncAO = &#123;</span><br><span class="line">    b: <span class="string">"var in outerFunc"</span>,</span><br><span class="line">    innerFunc: reference to <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span></span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>然后执行代码 <code>console.log(b);</code> ，打印 b 的属性值。</p></li><li><p>然后执行代码 <code>innerFunc();</code> ，进入 innerFunc 函数的执行阶段。</p></li></ol><h3 id="innerFunc-函数执行阶段"><a href="#innerFunc-函数执行阶段" class="headerlink" title="innerFunc() 函数执行阶段"></a>innerFunc() 函数执行阶段</h3><p>在执行 innerFunc() 函数前，Javascript 引擎会先对 innerFunc 函数代码进行解析，创建 innerFunc 函数的执行上下文 innerFuncContext。</p><ol><li><p>创建 innerFunc 函数执行上下文的活动对象 innerFuncAO。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innerFuncContext.innerFuncAO = &#123;</span><br><span class="line">    c: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复制 innerFunc 函数的 <code>[[Scope]]</code> 属性，为函数执行上下文的作用域链赋值，然后将函数执行上下文的活动对象压入作用域链顶端。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innerFuncContext.[[Scope]] = [</span><br><span class="line">    innerFuncContext.innerFuncAO,</span><br><span class="line">    outerFuncContext.outerFuncAO,</span><br><span class="line">    globalContext.globalVO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ol><p>innerFunc 函数执行上下文创建后，进入函数代码的执行阶段，将 innerFuncContext 压入执行上下文栈中，按顺序依次执行代码。</p><ol><li><p>在执行代码前，根据函数调用方式，判断得到 innerFuncContext 的 this 指向为 <code>globalVO</code>。</p></li><li><p>执行第一行代码 <code>var c = &quot;var in innerFunc&quot;;</code> ，为 innerFuncAO 的 c 属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innerFuncContext.innerFuncAO = &#123;</span><br><span class="line">    c: <span class="string">"var in innerFunc"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后执行代码 <code>console.log(c);</code> ，打印 c 的属性值。</p></li><li><p>然后执行代码 <code>foo();</code> ，进入 foo 函数的执行阶段，注意这里我们是通过作用域链找到的 foo 函数的引用。</p></li></ol><h3 id="foo-函数执行阶段"><a href="#foo-函数执行阶段" class="headerlink" title="foo() 函数执行阶段"></a>foo() 函数执行阶段</h3><p>在执行 foo() 函数前，Javascript 引擎会先对 foo 函数代码进行解析，创建 foo 函数的执行上下文 fooContext。</p><ol><li><p>创建 foo 函数执行上下文的活动对象 fooAO。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fooContext.fooAO = &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复制 foo 函数的 <code>[[Scope]]</code> 属性，为函数执行上下文的作用域链赋值，然后将函数执行上下文的活动对象压入作用域链顶端。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fooContext.[[Scope]] = [</span><br><span class="line">    fooContext.fooAO,</span><br><span class="line">    globalContext.globalVO</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li></ol><p>foo 函数执行上下文创建后，进入函数代码的执行阶段，将 fooContext 压入执行上下文栈中，按顺序依次执行代码。</p><ol><li><p>在执行代码前，根据函数调用方式，判断得到 fooContext 的 this 指向为 <code>globalVO</code>。</p></li><li><p>然后执行代码 <code>console.log(a);</code> ，根据作用域链找到 a 的属性值，然后打印它。</p></li></ol><h3 id="执行结束阶段"><a href="#执行结束阶段" class="headerlink" title="执行结束阶段"></a>执行结束阶段</h3><p>我们先来看一下此时的执行上下文栈</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu11-2.png" alt="配图11-2"></p><p>函数执行完成后是一个执行上下文弹栈的过程。</p><ol><li><p>在 foo() 函数代码执行完成后，执行上下文栈将 fooContext 弹栈，在没有其他引用的情况下，fooContext中的数据都将被销毁，然后将控制权交还给 innerFuncContext。</p></li><li><p>继续执行 innerFunc 函数，因为没有其余可执行代码，所以 innerFunc() 函数执行完成，执行上下文栈将innerFuncContext 弹栈，在没有其他引用的情况下，innerFuncContext中的数据都将被销毁，然后将控制权交还给 outerFuncContext。</p></li><li><p>继续执行 outerFunc 函数，因为没有其余可执行代码。所以 outerFunc() 函数执行完成，执行上下文栈将 outerFuncContext 弹栈，在没有其他引用的情况下，outerFuncContext中的数据都将被销毁，然后将控制权交还给 globalContext。</p></li><li><p>继续执行全局代码，在应用退出时，globalContext 弹栈，整段代码执行结束。</p></li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这个例子的分析基本结束了，通过这个示例分析，我对执行上下文中的三个属性间的联系有了更深刻的认识，对执行上下文也有了更深的理解，这样的分析对我们理解闭包等知识点有很大的帮助。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu15-1.jpg&quot; alt=&quot;JavaScript深入理解之执行上下文示例分析 文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;前面已经对执行上下文的创建及其三个属性做了总结，本篇文章通过一个示例分析来将前面的总结的知识点做一个串联与回顾。不了解执行上下文的同学可以先看我前面的几篇对执行上下文的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="执行上下文" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="执行环境" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之this详解</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之this详解.html</id>
    <published>2018-03-29T01:24:29.000Z</published>
    <updated>2018-11-21T15:43:24.841Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu14-1.jpg" alt="JavaScript深入理解之this详解 文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在文章<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html#more">《JavaScript深入理解之执行上下文》</a>中我们谈到了执行上下文一共有三个属性：变量对象、作用域链、this指针。本篇文章我们将介绍执行上下文最后一个重要的属性 —— this。this指向一直是一个老生常谈的问题，下面是我的一些理解和总结。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>this 指向最后一次调用这个方法的对象</p></blockquote><p>记住上面这句话，对于 this 的用法我们其实已经懂了一半了。在实际应用中，一共有四种调用方式：方法调用模式、函数调用模式、构造器调用模式和 apply 、 call 、 bind 调用模式。下面我们来分别看一下在这几种不同模式下 this 的指向。</p><h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时， this 被绑定到该对象。</p><p>那么我们怎么来判断一个函数是否是被作为方法来调用呢？ 如果调用表达式包含一个提取属性的动作（即包含一个 <code>.</code> 点或 <code>[subscript]</code> 下标表达式），那么它就是被当做一个方法来调用。</p><p>下面我们来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObjct = &#123;</span><br><span class="line">    value: <span class="number">1</span>;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObjct.increment(); <span class="comment">// myObject 调用 increment() 方法，this 指向 myObject 对象 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mvObject.value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>方法可以使用 this 访问自己所属的对象，所以它能从对象中取值或对对象进行修改。 this 到对象的绑定发生在函数调用的时候，而不是函数定义的时候。</p><h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><p>当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。如下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">increment(); <span class="comment">// 作为函数调用， this 绑定到全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此模式来调用函数时，this被绑定到全局对象。</p><p>这其实是语言设计上的一个错误。倘若语言设计正确，那么当内部函数被调用时，this 应该仍然绑定到外部函数的 this 变量（其他大部分语言都是这样实现的）。</p><p>这个设计错误的结果就是方法不能利用内部函数来帮助它工作，因为内部函数的 this 被绑定了错误的值，所以不能共享该方法对对象的访问权。</p><p>不过我们可以通过定义一个变量并给它赋值为 this 来解决，常用的如 that。</p><h2 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h2><p>如果在一个函数前面带上 new 调用，那么背地里将会创建一个连接到该函数的 prototype 成员的新对象，同时 this 也会被绑定到那个新对象上。</p><p>如下面例子所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peo = <span class="keyword">new</span> person(<span class="string">"xiao ming"</span>); <span class="comment">// this 绑定到 peo 对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(peo.name); <span class="comment">// "xiao ming"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数，如果创建的目的就是希望结合 new 前缀来调用，那么它就被称为构造器函数。按照约定，它们保存在以大写格式命名的变量里。</p><h2 id="apply-、-call-和-bind-调用模式"><a href="#apply-、-call-和-bind-调用模式" class="headerlink" title="apply 、 call 和 bind 调用模式"></a>apply 、 call 和 bind 调用模式</h2><p>这三个方法用途都是在特定的作用域中调用函数，简单说就是用于指定函数调用时 this 指向的对象。下面我们分别来讲讲它们用法的不同。</p><h3 id="apply-调用"><a href="#apply-调用" class="headerlink" title="apply 调用"></a>apply 调用</h3><p>apply() 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。</p><p>如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">""</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setName.apply(person,[<span class="string">"xiao"</span>,<span class="string">"ming"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "xiao ming" </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">firstName,lastName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call-调用"><a href="#call-调用" class="headerlink" title="call 调用"></a>call 调用</h3><p>call() 方法和 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call() 方法而言，第一个参数是 this 值没有变化，变化的其余参数都直接传递给函数。换句话说，在使用 call() 方法时，传递给函数的参数 必须逐个列举出来。</p><p>如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">""</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setName.call(person,<span class="string">"xiao"</span>,<span class="string">"ming"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// "xiao ming" </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">firstName,lastName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind-调用"><a href="#bind-调用" class="headerlink" title="bind 调用"></a>bind 调用</h3><p>ES5中新定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。</p><p>如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">        color: <span class="string">"blue"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o); <span class="comment">// 创建新的函数实例，并将其 this 值绑定为 o 对象</span></span><br><span class="line"></span><br><span class="line">objectSayColor();<span class="comment">// "blue"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了，使用 bind() 函数创建的实例，即使在全局作用域中调用这个函数，this 绑定的依然是 o 对象。</p><p>不过我们需要注意一点，如果将 bind() 函数创建的实例作为构造器函数使用时，它的 this 值会绑定为新创建的对象，而不再是 bind() 时绑定的对象了。</p><h2 id="还有一点疑问"><a href="#还有一点疑问" class="headerlink" title="还有一点疑问"></a>还有一点疑问</h2><p>其实了解了上面几种调用方式后，我们对 this 应该说已经足够了解了。那么让我们来看一下下面这道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)()); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//示例4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//示例5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>看完后是不是有一种头大的感觉，怎么，怎么感觉没一个对得上……</p><p>要想解决这些疑惑，或许我们应该从 this 的规范入手，下面推荐一篇文章<a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">《JavaScript深入之从ECMAScript规范解读this 》</a>。作者给我们提供了一个很好的思路去从规范的角度理解 this 。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>好了，关于 this 的总结暂时先到这里了。对于一般的 this 指向问题，我们了解这四种调用模式其实就已经足够了，而且通过调用方式的角度是最适合我们理解的。当然了我在文章的末尾提出的那道问题，涉及到的就不是仅仅使用调用模式就能够理解的，我们需要从规范的角度去理解，我是认为这种方式应该是最有效的，但很不容易理解，后边有时间我会再从规范角度去总结一下 this 的指向问题。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu14-1.jpg&quot; alt=&quot;JavaScript深入理解之this详解 文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在文章&lt;a href=&quot;http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html#more&quot;&gt;《JavaScript深入理解之执行上下文》&lt;/a&gt;中我们谈到了执行上下文一共有三个属性：变量对象、作用域链、this指针。本篇文章我们将介绍执行上下文最后一个重要的属性 —— this。this指向一直是一个老生常谈的问题，下面是我的一些理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="执行上下文" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="this" scheme="http://cavszhouyou.top/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之作用域链</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之作用域链.html</id>
    <published>2018-03-28T08:37:07.000Z</published>
    <updated>2018-11-21T15:43:24.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu13-1.jpg" alt="JavaScript深入理解之作用域链文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在文章<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html#more">《JavaScript深入理解之执行上下文》</a>中我们谈到了执行上下文一共有三个属性：变量对象、作用域链、this指针。本篇文章我们将介绍执行上下文第二个重要的属性 —— 作用域链，希望大家建立在对执行上下文和变量对象概念有一定了解的基础上阅读。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。</p></blockquote><p>在上一篇文章中我们介绍了变量对象里边包含了执行上下文中所有变量和函数的声明，它的作用就是保证代码执行时对变量和函数的正确访问。如果在该变量对象中没有找到对应变量或函数，则会根据执行作用域链向上继续查找，这就是我们今天要介绍的主题。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>作用域链本质上是一个指向变量对象的指针列表（在文中我们使用数组表示），它只引用但不实际包含变量对象。作用域链的前端始终都是当前执行上下文的变量对象，如果这个执行上下文属于函数执行上下文，则用活动对象作为变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><p>一般我们都认为作用域链是在函数定义时就已经创建好的，所以它只和定义时的函数包含关系有关。这样理解作用域链其实看似很清晰，但其实只是片面的理解。因为大家有没有想过一个问题，如果一开始就定义好，和代码执行阶段没有关系的话，那我们是如何来访问那些在代码执行中动态变化的对象的呢？</p><p>这其实是一个动态的创建过程，下面我们通过一个例子来看一下作用域链的创建过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">compare(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    inner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( value1 &gt; value2 ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局阶段"><a href="#全局阶段" class="headerlink" title="全局阶段"></a>全局阶段</h3><p>我们从程序开始时讲起。首先在执行全局代码前，我们会先创建全局上下文。创建全局上下文的第一步是创建全局变量对象，然后将全局变量对象放入作用域链的顶端(执行上下文中的<code>[[Scope]]</code>属性指向作用域链)。如下图所示（图中省略了其他属性），</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu13-2.png" alt="配图13-2"></p><p>此时全局上下文中的<code>[[Scope]]</code>属性可以这样表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globalContext.[[Scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>注意在创建完作用域链后，JavaScript 引擎还做了另一件事，这也是实现作用域链的最关键的一步，它会为变量对象中的所有函数添加一个<code>[[Scope]]</code>属性，而这个属性的值就是我们刚才介绍的全局上下文中的<code>[[Scope]]</code>属性值。如下，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compare.[[Scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="函数阶段"><a href="#函数阶段" class="headerlink" title="函数阶段"></a>函数阶段</h3><p>全局上下文创建后，开始执行代码，根据代码动态的修改变量对象中的属性，当我们执行到<code>compare(5,10)</code>时，让我们来看一看在函数阶段是如何创建作用域链的。</p><p>首先在执行<code>compare(5,10)</code>之前，我们会为函数创建对应的执行上下文。<strong>注意重点来了</strong>函数上下文首先会复制函数的<code>[[Scope]]</code>属性用来创建作用域链，然后用 arguments 创建活动对象，最后再将活动对象压入作用域链顶端，如下所示，</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu13-3" alt="配图13-3"></p><p>comapre执行上下文复制<code>[[Scope]]</code>属性创建作用域链后可以这样表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compareContext = &#123;</span><br><span class="line">    Scope: compare.[[Scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压入活动对象后作用域链如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkScopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建好作用域链后，JavaScript 引擎同样会判断函数执行上下文的活动对象中的函数声明，然后为变量对象中的所有函数添加一个<code>[[Scope]]</code>属性，而这个属性的值就是当前函数上下文中的<code>[[Scope]]</code>属性值。如所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inner.[[Scope]] = [</span><br><span class="line">   checkScopeContext.AO, </span><br><span class="line">   globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在代码执行阶段会对函数上下文中属性动态修改，因为作用域链是对变量对象的引用，因此我们可以实时地获取变量对象的最新状态，保证对作用域链查询时能够保证变量的准确性。</p><p>接下来对于 inner 函数，在执行到它时会继续这些上面同样的操作来创建作用域链，这就是我为什么说作用域链的创建是一个动态的过程的原因。</p><h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>相信大家通过上面的讲解已经明白了作用域链是如何创建的了，下面我们小结一下。</p><ol><li><p>全局上下文阶段，创建全局对象。</p></li><li><p>将全局对象压入作用域链</p></li><li><p>为全局对象中所有函数创建<code>[[Scope]]</code>属性，并将作用域链保存到该属性。（若无函数则跳过此步骤）</p></li><li><p>每一个函数上下文阶段，复制函数的<code>[[Scope]]</code>属性，创建作用域链</p></li><li><p>创建活动对象，并用 arguments 创建活动对象  </p></li><li><p>将活动对象压入当前上下文中的作用域链</p></li><li><p>为活动对象中所有函数创建<code>[[Scope]]</code>属性，并将作用域链保存到该属性。（若无函数则跳过此步骤）</p></li></ol><h2 id="扩展作用域链"><a href="#扩展作用域链" class="headerlink" title="扩展作用域链"></a>扩展作用域链</h2><p>虽然执行上下文的类型总共只有两种———全局和局部（函数），但还是有办法延长作用域链的。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况会发生这种现象，如下：</p><ul><li><p>try-catch 语句中的 catch 块</p><p>当 catch 语句执行时，会创建一个新的变量对象，其中包含了被抛出的错误对象的声明，然后将这个变量对象压入当前上下文作用域链中。</p></li><li><p>with 语句</p><p>当 with 语句执行时，会将 with () 中指定的对象压入当前上下文作用域链中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number  = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span>(location)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会将 location 对象添加到当前上下文作用域链的顶端。</p></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>好啦，作用域链的总结就基本到这里了。作用域链的理解对于 JavaScript 中如闭包等的理解很有帮助，这是一个很基础和重要的知识点，理解后的确有一种豁然开朗的感觉。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu13-1.jpg&quot; alt=&quot;JavaScript深入理解之作用域链文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在文章&lt;a href=&quot;http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html#more&quot;&gt;《JavaScript深入理解之执行上下文》&lt;/a&gt;中我们谈到了执行上下文一共有三个属性：变量对象、作用域链、this指针。本篇文章我们将介绍执行上下文第二个重要的属性 —— 作用域链，希望大家建立在对执行上下文和变量对象概念有一定了解的基础上阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="执行上下文" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="变量对象" scheme="http://cavszhouyou.top/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="作用域链" scheme="http://cavszhouyou.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之变量对象</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之变量对象.html</id>
    <published>2018-03-26T09:40:39.000Z</published>
    <updated>2018-11-21T15:43:24.889Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu12-1.jpg" alt="JavaScript深入理解之变量对象"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在文章<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html#more">《JavaScript深入理解之执行上下文》</a>中我们谈到了执行上下文一共有三个属性：变量对象、作用域链、this指针。本篇文章我们将介绍执行上下文第一个重要的属性 —— 变量对象，希望大家建立在对执行上下文概念有一定了解的基础上阅读。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>变量对象（Variable object，VO）是与执行上下文相关的数据作用域，存储了在执行上下文中定义的所有变量和函数声明，保证代码执行时对变量和函数的正确访问。</p></blockquote><p>简单的来它说存储着执行上下文中的以下内容：</p><ol><li>函数的所有形参(如果是函数执行上下文)<ul><li>由名称和对应值组成，作为变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)，指向对函数的引用）组成，作为变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成，作为变量对象的属性被创建</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>我们用一个例子来理解一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>foo(1)</code> 函数执行上下文对应的 VO （其实是AO，后边会介绍到）为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现。</p><h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>不同执行上下文中的变量对象是不同的，根据可执行代码的不同我们可以将执行上下文分为两种，一种是全局执行上下文，一种是函数执行上下文。因此我们也可以将变量对象分为对应的两种，一种是全局上下文变量对象，一种是函数上下文变量对象。那么它们和变量对象是什么关系呢？可以这样理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">抽象变量对象VO (变量初始化过程的一般行为)</span><br><span class="line">  ║</span><br><span class="line">  ╠══&gt; 全局上下文变量对象GlobalContextVO，等同于全局对象</span><br><span class="line">  ║        (VO === this === global)</span><br><span class="line">  ║</span><br><span class="line">  ╚══&gt; 函数上下文变量对象FunctionContextVO，等同于活动对象（Variable object，VO）</span><br><span class="line">           (VO === AO, 并且添加了&lt;arguments&gt;和&lt;formal parameters&gt;)</span><br></pre></td></tr></table></figure><p>变量对象其实只是一个抽象的基本事物，它规定了一些基本的操作（如变量初始化）和行为，不同执行上下文中的不同实现都是基于这些行为来创建的。其实不必太过纠结于这个概念，我们只需要记住在全局执行上下文中我们通过<strong>全局对象</strong>来代表全局上下文变量对象，在函数上下文中我们通过<strong>活动对象</strong>来代表函数上下文变量对象。下面我们来分别介绍它们。</p><h2 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h2><p>相信大家都已经猜到了，全局上下文中的变量对象就是全局对象，因为它们拥有的特征太像了。</p><p>我们先来看一下全局对象的定义：</p><blockquote><p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。</p><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。但通常不必用这种方式引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p><p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p></blockquote><p>我们再来看一下全局上下文中的变量对象的特点：</p><ul><li>全局上下文中的变量对象在执行所有代码之前创建。</li><li>全局上下文中的变量对象一直存在，直到程序结束。</li><li>全局上下文中的变量对象保存了全局上下文中所有的变量和函数声明</li><li>全局变量对象位于作用域链的顶端 </li></ul><p>其实对照起来一看，我们就会明白为什么会说全局上下文中的变量对象就是全局对象了。但全局对象除了含有变量对象的特点外，它还做了其他事，那就是在初始化时会将 Math 、 String 、Date、parseInt 等作为自身属性，这也是为什么我们可以访问使用这些函数和属性的原因。</p><p>讲了这么多，其实我们只要记住全局上下文中的变量对象就是全局对象就行了。</p><h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object ，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象，它包括如下属性：</p><ul><li>callee — 指向当前函数的引用</li><li>length — 真正传递的参数个数</li><li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。</li></ul><p>注意，arguments 代表的是真正传入函数的参数列表（不受参数个数限制），和函数参数是分开的。</p><h2 id="变量对象的两个阶段"><a href="#变量对象的两个阶段" class="headerlink" title="变量对象的两个阶段"></a>变量对象的两个阶段</h2><p>我们知道一段可执行代码分为解析和执行两个阶段，变量对象的创建和赋值分别对应了这两个阶段。</p><h3 id="代码解析阶段"><a href="#代码解析阶段" class="headerlink" title="代码解析阶段"></a>代码解析阶段</h3><p>在代码解析阶段，会根据执行上下文中的变量声明和函数声明来创建变量对象，具体创建方式已经在定义部分讲过了。注意此时除了函数上下文可以根据传入的参数对 arguments 属性赋值以外，其他声明的属性的值都为 undefined ，即未定义。</p><h3 id="代码执行阶段"><a href="#代码执行阶段" class="headerlink" title="代码执行阶段"></a>代码执行阶段</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值。</p><p>定义部分的例子，代码执行完，这时候的 AO 是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/8f19e45fd1f1" target="_blank" rel="noopener">《JavaScript 论代码执行上下文》</a><br><a href="https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html#!comments" target="_blank" rel="noopener">《深入理解JavaScript系列（12）：变量对象（Variable Object）》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">《JavaScript深入之变量对象》</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>变量对象这一个属性算是基本总结完了，后面还会有执行上下文另外两个属性的总结。其实在写文章前我认为我已经弄懂变量对象了，但真正总结的时候才发现，存在疑惑的地方还有很多，写的很纠结……不过很多东西还是慢慢来吧。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu12-1.jpg&quot; alt=&quot;JavaScript深入理解之变量对象&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在文章&lt;a href=&quot;http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html#more&quot;&gt;《JavaScript深入理解之执行上下文》&lt;/a&gt;中我们谈到了执行上下文一共有三个属性：变量对象、作用域链、this指针。本篇文章我们将介绍执行上下文第一个重要的属性 —— 变量对象，希望大家建立在对执行上下文概念有一定了解的基础上阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="执行上下文" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="变量对象" scheme="http://cavszhouyou.top/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之执行上下文</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之执行上下文.html</id>
    <published>2018-03-24T11:34:43.000Z</published>
    <updated>2018-11-21T15:43:24.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu11-1.jpg" alt="JavaScript深入理解之执行上下文 文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>JavaScript 中的执行上下文（ Execution Context ）相信大家都不陌生，也就是我们常说的执行环境。想要弄懂 JavaScript 代码的执行过程，执行上下文是其中最重要的一个知识点。理解执行上下文有助于我们理解函数作用域链、变量对象和 this 指向等。这两天查阅了很多资料，下面是我对执行上下文的一个理解和总结。</p><a id="more"></a><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>众所周知 JavaScript 是一种描述型的脚本语言，不同于 C# 或者 java ，它不需要编译成中间语言，而是由 JS 引擎动态的解析和执行。那么 JavaScript 引擎是如何解析和执行一段 JavaScript 代码的呢？让我们先来看一个小例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test(); <span class="comment">// this is a function!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is a function!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以看出，test 函数调用在它的声明之前，按道理应该调用失败才对！而事实是 test 函数能够被正常调用，原因是 test 函数的声明被提升了，使得 test 函数在整个代码执行期间都可以访问到。那声明是什么时候提升的呢？就是在 JavaScript 引擎对代码解析的时候。</p><p>因此我们一定要记住，JavaScript 引擎在执行一段可执行代码之前，会先进行准备工作，也就是对这段代码进行解析（也可以称为预处理）。这个阶段会根据<strong>可执行代码</strong>创建相应的<strong>执行上下文（ Execution Context ）</strong>，也就是做声明提升等工作（后边会详细讲解）。然后在代码解析完成后才开始代码的执行。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里我们需要注意的一点是， JavaScript 引擎解析执行代码的过程是一个边执行边解析的过程，解析发生在执行一段可执行代码之前。举个例子，当执行到一个函数的时候，就会先对这个函数进行解析，然后再执行这个函数。</p><h2 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h2><p>上面我们提到了，在代码解析阶段会根据不同的可执行代码创建相应的执行上下文，那么可执行代码有哪些呢？其实可以分为下面三种：</p><ul><li>全局执行代码，在执行所有代码前，解析创建全局执行上下文。</li><li>函数执行代码，执行函数前，解析创建函数执行上下文。</li><li>eval执行代码，运行于当前执行上下文中。</li></ul><h2 id="执行上下文的组成"><a href="#执行上下文的组成" class="headerlink" title="执行上下文的组成"></a>执行上下文的组成</h2><p>执行上下文定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每一个执行上下文都由以下三个属性组成。</p><ul><li><p>变量对象（Variable object，VO）</p></li><li><p>作用域链(Scope chain)</p></li><li><p>this</p></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>执行每一段可执行代码时都会对应创建一个执行上下文，那么我们是如何来管理这些执行上下文的呢？JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。 </p><p>下面我们通过一个例子来看一下执行上下文压栈是如何工作的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"global var"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"var in outerFunc"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">"var in innerFunc"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    innerFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunc();</span><br></pre></td></tr></table></figure><p>代码首先进入Global Execution Context，然后依次进入outerFunc，innerFunc和foo的执行上下文，执行上下文栈就可以表示为：</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu11-2.png" alt="配图11-2"></p><p>JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以 JavaScript 引擎会先解析创建全局执行上下文，然后将全局执行上下文压栈。然后当执行流进入一个函数时，会先解析创建函数的执行上下文，然后将它的执行上下文压栈。而在函数执行之后，会将其执行上下文弹栈，弹栈后执行上下文中所有的数据都会被销毁，然后把控制权返回给之前的执行上下文。注意，全局执行上下文会一直留在栈底，直到整个应用结束。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本篇文章只是对执行上下文做一个初步的介绍，为后面讲解执行上下文的三个属性作一个铺垫。先了解创建执行上下文这个过程，然后再去分析过程里边的细节。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu11-1.jpg&quot; alt=&quot;JavaScript深入理解之执行上下文 文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;JavaScript 中的执行上下文（ Execution Context ）相信大家都不陌生，也就是我们常说的执行环境。想要弄懂 JavaScript 代码的执行过程，执行上下文是其中最重要的一个知识点。理解执行上下文有助于我们理解函数作用域链、变量对象和 this 指向等。这两天查阅了很多资料，下面是我对执行上下文的一个理解和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="执行上下文" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="执行环境" scheme="http://cavszhouyou.top/tags/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之RegExp类型详解</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BRegExp%E7%B1%BB%E5%9E%8B.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之RegExp类型.html</id>
    <published>2018-03-22T12:21:22.000Z</published>
    <updated>2018-11-21T15:43:24.817Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu10-1.jpg" alt="JavaScript深入理解之RegExp类型详解文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们在验证输入或查找字符时经常需要用到正则表达式，正则表达式的强大毋庸置疑。在 JavaScript 中也提供了 RegExp 类型来作为相应的支持。下面是我对 RegExp 类型的看法和总结。</p><a id="more"></a><h2 id="RegExp-对象的创建"><a href="#RegExp-对象的创建" class="headerlink" title="RegExp 对象的创建"></a>RegExp 对象的创建</h2><p>ECMAScript 通过 RegExp 类型来支持正则表达式。一共有两种创建方式，一种是以字面量形式来定义的正则表达式，另一种是使用 RegExp 构造函数来创建正则表达式。下面我们来分别介绍一下。</p><h3 id="字面量形式"><a href="#字面量形式" class="headerlink" title="字面量形式"></a>字面量形式</h3><p>使用下面类似 Perl 的语法，就可以创建一个正则表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags</span><br></pre></td></tr></table></figure><p>其中模式( pattern )部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式可以带有一个或多个标志，用以标明正则表达式的行为。正则表达式的匹配模式支持下列三个标志。</p><ul><li><code>g</code>: 表示全局模式，即模式将应用于所有字符串，而非在发现第一个匹配项时就停止检索。</li><li><code>i</code>: 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写。</li><li><code>m</code>: 表示多行匹配模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。 </li></ul><p>下面我们来看几个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 匹配字符串中所有"at"的实例</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配字符串中的第一个"at"，不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/at/i</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配字符串中所有的"at"，不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/at/gi</span>;</span><br></pre></td></tr></table></figure><p>注意，模式中使用到的元字符需要转义。正则表达式中的元字符包括: <code>( ) [ ] { } \ ^ $ | ? * + .</code><br>因为这些元字符在正则表达式中有特殊的用途，所以如果需要匹配的字符串中含有这些字符，这必须对其转义，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中的第一个" [at] ",不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\[at\]/i</span> ;</span><br></pre></td></tr></table></figure><h3 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a>RegExp 构造函数</h3><p>另一种创建正则表达式的方法是使用 RegExp 构造函数，它接收两个参数，一个是要匹配的字符串模式，另一个是可选的标志字符串。只要是可以用字面量定义的任何任何表达式，都可以用构造函数来定义。如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中所有"at"的实例</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"at"</span>,<span class="string">"g"</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意，我们传递给构造函数的两个参数都是字符串的形式，所以这里会涉及到一个转义问题。因为是由字符串转化为正则表达式，所以所有的元字符都必须进行双重转义，如下面的例所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量形式</span></span><br><span class="line">/\[at\]/</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数中使用的双重定义的字符串</span></span><br><span class="line"><span class="string">"/\\[at\\]/"</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里对于这两种方法有一个区别需要注意，在 ES3 的规定中，使用正则表达式字面量始终会共享一个 RegExp 实例，而使用构造函数创建的每一个新 RegExp 实例都是一个新实例。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在ES3 环境下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字面量形式创建</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">0</span>;i++)&#123;</span><br><span class="line">    re = <span class="regexp">/cat/g</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(re.test(<span class="string">"catastrophe"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果为 true false true false true false true false true false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数创建</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">0</span>;i++)&#123;</span><br><span class="line">    re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>,<span class="string">"g"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(re.test(<span class="string">"catastrophe"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为 true true true true true true true true true true</span></span><br></pre></td></tr></table></figure><p>下面我们来分析以下上面两个例子。</p><p>第一个例子中因为正则表达式字面量共享一个实例，所以实例属性不会重置。在第一次调用 test() 方法找到了 “cat” 后返回 true ，但第二次调用是从索引为3的字符(上一次匹配的末尾)开始的，所以第二次就找不到它了，返回 false 。由于会测试到字符串末尾，所以下一次调用 test() 就又从头开始了，所以继续返回 true 和 false 的循环。</p><p>第二个例子使用构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的 RegExp 实例，所以每次调用都会返回 true 。</p><p>上面我们说了，这是在 ES3 下的表现。在 ES5 中对此作出了明确规定，使用字面量形式时也会像直接调用 RegExp 构造函数一样，每次创建新的 RegExp 实例。所以第一个例子在 ES5 下每次也都会返回 true 。因为现在 ES5 普及度已经很高了，所以上面的区别仅做一个了解，在实际应用中多数情况下不用考虑这个问题。</p><h2 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h2><p>RegExp 的每个实例都有以下属性，通过这些属性可以取得有关模式的各种信息。</p><ul><li>global ：布尔值，表示是否设置了 g 标志。</li><li>ignoreCase ：布尔值，表示是否设置了 i 标志。</li><li>multiline ： 布尔值，表示是否设置了 m 标志。</li><li>lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li><li>source ： 正则表达式的字符串表示，<strong>按照字面量的形式而非传入构造函数中的字符串模式返回</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[at\\]"</span>,<span class="string">"g"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pattern.global); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.ignoreCase); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.multiline); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.source); <span class="comment">// "\[at\]at"</span></span><br></pre></td></tr></table></figure><p>通过这些属性来获得一个正则表达式的各方面信息，其实这在实际应用中没有多大的用处，因为这些信息基本都包含在了模式声明中，所以仅做了解就好。</p><h2 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h2><p>RegExp 实例一共有两个主要的方法 exec() 方法和 test() 方法，下面我们分别看一下它们的用法。</p><h3 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec() 方法"></a>exec() 方法</h3><p>exec() 方法是专门为捕获组设计的。该方法接受一个参数，就是需要应用模式的字符串，然后返回包含第一个匹配项信息的数组，如果没有匹配项则返回 null。返回的数组虽然是 Arrey 的实例，但包含了两个额外的属性：index 和 input。index表示匹配项在字符串中的位置，而 input 则表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他是与模式中匹配的字符串(如果模式中没有捕获组，则数组仅包含第一项)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]); <span class="comment">// " dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure></p><p>对于 exec() 方法而言，无论模式中是否设置了全局标志，它每次都只会返回第一个匹配项。对于同一个字符串多次调用 exec() 方法，在不设置全局标志的情况下，将始终返回第一个匹配项的信息，在设置了全局标志的情况下，每次调用 exec() 方法否会在字符串中继续查找新匹配项。 </p><h3 id="test-方法"><a href="#test-方法" class="headerlink" title="test() 方法"></a>test() 方法</h3><p>test() 方法适用于只想知道目标字符串与某个模式是否匹配，但不需要知道文本内容的情况。该方法接受一个字符串参数，在模式与该参数匹配时返回 true ，不匹配时返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern =  <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pattern.test(text)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>RegExp 实例继承的 toLocalString() 和 toString() 方法都会返回正则表达式的字面量，而 valueOf 则返回正则表达式本身。</p><h2 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h2><p>RegExp 构造函数包含一些属性(这些属性在其他语言中被看为静态属性)。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。这些属性分别有一个长属性名和一个短属性名( Opera 是例外，它不支持短属性名)。</p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串。 Opera未实现此属性</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项。 Opera未实现此属性</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次的捕获组。 Opera未实现此属性</td></tr><tr><td>leftContext</td><td>$`</td><td>input 字符串中 lastMatch 之前的字符串</td></tr><tr><td>rightContext</td><td>$’</td><td>input 字符串中 lastMatch 之后的字符串</td></tr><tr><td>multitline</td><td>$*</td><td>布尔值，表示是否所有的表达式都使用多行模式。 IE和Opera未实现此属性</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input); <span class="comment">// this has been a short summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// this has been a</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// short</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastPaern); <span class="comment">// s </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.multitline); <span class="comment">// false </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面所说的一样，例子中使用的长属性名可以使用短属性名来代替。只不过，由于这些短属性名大都不是有效的 ECMAScript 字符，所以必须通过方括号语法来访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>除了上面介绍到的几个属性外，还有多大9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1到RegExp.$9，分别用于存储第一到第九个匹配的捕获组。在调用 exec() 方法和 test() 方法时，这些属性会被自动填充。</p><h2 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h2><p>尽管 ECMAScript 中的正则表达式还是比较完备的，但还是缺少某些语言(特别是 Perl )所支持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性。</p><ul><li>匹配字符串开始和结尾的 \A 和 \Z 锚，但支持以插入符号<code>^</code>和美元符号<code>$</code>来匹配字符串的开始和结尾。</li><li>先后查找，但支持向前查找</li><li>原子组</li><li>Unicode 支持(单个字符除外如 \uFFFF )</li><li>命名的捕获组，但支持编号的捕获组</li><li>单行和无间隔匹配模式</li><li>条件匹配</li><li>正则表达式注释</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于 RegExp 类型的总结就到这里，其实一些复杂的属性在平常很少会用到，但这些东西还是要做一个了解，避免需要用到的时候没有头绪。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu10-1.jpg&quot; alt=&quot;JavaScript深入理解之RegExp类型详解文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;我们在验证输入或查找字符时经常需要用到正则表达式，正则表达式的强大毋庸置疑。在 JavaScript 中也提供了 RegExp 类型来作为相应的支持。下面是我对 RegExp 类型的看法和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="RegExp" scheme="http://cavszhouyou.top/tags/RegExp/"/>
    
      <category term="正则表达式" scheme="http://cavszhouyou.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之Date类型详解</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BDate%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之Date类型详解.html</id>
    <published>2018-03-18T12:46:05.000Z</published>
    <updated>2018-11-21T15:43:24.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu9-1.jpg" alt="JavaScript深入理解之Date类型详解 文章配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Date 类型平常用得不是很多，但一用到，对它的使用就感到不是很熟悉，每次都是强行百度一波，可以看出自己的基础不是很牢。所以最近决定静下心来好好回顾一下以前自己忽视的基础，下面是我对 Date 类型的一些总结和看法。</p><a id="more"></a><h2 id="UTC-和-GMT-及-北京时间的关系"><a href="#UTC-和-GMT-及-北京时间的关系" class="headerlink" title="UTC 和 GMT 及 北京时间的关系"></a>UTC 和 GMT 及 北京时间的关系</h2><p>在介绍Date类型前，我们先来了解一下 UTC 和 GMT 及 北京时间的关系。</p><ul><li><p>GMT 即「格林威治标准时间」(Greenwich Mean Time，简称G.M.T.)，指位于英国伦敦郊区的皇家格林威治天文台的标准时间，因为本初子午线被定义为通过那里的经线。然而由于地球的不规则自转，导致GMT时间有误差，因此目前已不被当作标准时间使用。</p></li><li><p>UTC 是最主要的世界时间标准，是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间。 UTC 比 GMT 来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使 UTC 与地球自转周期一致。不过日常使用中，GMT 与 UTC 的功能与精确度是没有差别的，我们在文章中提到的 GMT 时间与 UTC 时间是一样的。</p></li><li><p>GMT = UTC    </p></li><li><p>因为时区的问题北京时间和UTC时间有这样的关系 <code>UTC + 8 = 北京时间</code> ， 这个公式有助于我们后面理解 Date 类型为什么在不同方法下的转换结果不同。</p></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此 Date 类型使用自 UTC ( Coordinated Universal Time, 国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date()类型保存的日期能够精确到1970年1月1日之前或之后的100 000 000年。</p></blockquote><p>我们可以这样理解，我们创建的一个 Date 对象中保存有一个 value，这个 value 的大小是从 UTC 时间1970年1月1日午夜至指定时间经过的毫秒数的大小。</p><p>这个值其实就是我们经常使用到的时间戳，需要注意的是js内的时间戳指的是指定时间到1970年1月1日00:00:00 UTC对应的毫秒数，和unix时间戳不是一个概念，后者表示秒数，差了1000倍。因此我们在转换时经常会遇到精度丢失的问题(暂时采用这种说法)。</p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>要创建一个日期对象，使用 new 操作符和 Date 构造函数即可，如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 获得当前时间</span></span><br></pre></td></tr></table></figure><p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获取当前日期和时间。如果想要根据指定的日期和时间创建对象，必须传入该日期的毫秒数(即从 UTC 时间1970年1月1日午夜至指定时间经过的毫秒数。)听起来是不是有点头大，难道我们还要自己计算好毫秒数才能创建相应的时间对象吗？这样岂不是太麻烦了？</p><h2 id="Date-parse-和-Date-UTC"><a href="#Date-parse-和-Date-UTC" class="headerlink" title="Date.parse() 和 Date.UTC()"></a>Date.parse() 和 Date.UTC()</h2><p>针对上面的问题ECMAScript提供了两个方法 Date.parse() 和 Date.UTC() ,以此来简化这一计算过程。它们会根据我们传入的参数来自动计算出毫秒数的大小。下面我们来分别介绍一下这两个方法。</p><h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p>Date.parse()方法接受一个表示日期的字符串参数，然后尝试根据这个字符串返回相应的毫秒数，如果传入的字符串不能表示将日期则返回NaN。因为ECMA-262没有定义这个方法应该支持那种日期格式，因此这个方法的行为通常是因地区而异。例如将地区设置为美国的浏览器通常都接受下列日期格式:</p><ul><li>“月/日/年”，如6/13/2004;</li><li>“英文月名日，年”，如January12，2004;</li><li>“英文星期几 英文月名 日 年 时：分：秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700。</li><li>ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ（例如2004-05-25T00:00:00）。只有兼容ECMAScript 5的实现支持这种格式。</li></ul><p>例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br></pre></td></tr></table></figure><h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p>Date.UTC()方法同样也返回表示日期的毫秒数。但它需要的参数不是字符串，它的参数分别是年份，基于0的月份(0到11)，日(1到31)，小时(0到23)，分钟，秒以及毫秒数。这些参数里边只有前两个参数是必需的，如果没有提供日值，则默认日值为1，其余参数未指定则默认为0。如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GMT时间2000年1月1日午夜零时： </span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//GMT时间2005年5月5日下午5:55:55： </span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>UTC 日期指的是在没有时区偏差的情况下(将日期转换为GMT时间)的日期值。 Date.parse() 方法是基于本地时区建立的，而 Date.UTC() 方法是基于无时区偏差建立的。所以如果我们对两个方法传入相同的时间，我们会发现 Date.parse() 方法得到的毫秒数相对于 Date.UTC() 方法得到的毫秒数会多八个小时的毫秒数(这里的本地时区指的是北京时间)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们传入相同的时间2018年3月18日</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">"3/18/2018"</span>); <span class="comment">// 1521302400000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.UTC(<span class="number">2018</span>,<span class="number">2</span>,<span class="number">18</span>); <span class="comment">//1521331200000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1521302400000 - 1521331200000 = 28800000 = 8 x 60 x 60 x 1000</span></span><br></pre></td></tr></table></figure></li><li><p>如果我们输入的日期值超过了正常的范围，在不同的浏览器中的会有不同的处理方式。例如在解析<code>&quot;January 32，2007&quot;</code>时，有的浏览器会将其解析为<code>&quot;February 1，2007&quot;</code>。而Opera浏览器则倾向于插入当前月份的当前日期值，返回<code>&quot;January 当前日期值，2007&quot;</code>。</p></li><li><p>其实我们没有必要在创建一个 Date 对象的时候显式调用 Date.parse() 和 Date.UTC() 方法，因为将相应的参数传入构造函数后，它会根据参数的类型在后台自动调用Date.parse() 或 Date.UTC() 方法，这样得到日期和时间都是基于本地时区的，就算你存入的参数类型是 Date.UTC() 方法所需的参数类型，最后得到的结果还是基于本地时区的结果。</p></li></ul><h2 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h2><p>ES5添加了Date.now()方法，用来返回表示调用这个方法时的日期和时间的毫秒数。这个方法可以用来分析函数的运行时间，如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得开始时间</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结束时间</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到函数运行时间</span></span><br><span class="line"><span class="keyword">var</span> runtime = start - end;</span><br></pre></td></tr></table></figure><p>在不支持它的浏览器中，我们可以通过<code>+</code>操作符获取Date对象的时间戳，也可以达到同样的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得开始时间</span></span><br><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结束时间</span></span><br><span class="line"><span class="keyword">var</span> end = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到函数运行时间</span></span><br><span class="line"><span class="keyword">var</span> runtime = start - end;</span><br></pre></td></tr></table></figure><h2 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>和其他引用类型一样，Date 类型也重写了 toLocaleString() 、toString() 和 valueOf() 方法，但这些方法的返回值与其他类型中的方法不同。</p><ul><li><p>Date 类型的 toLocalString() 方法会按照浏览器设置的时区相适应的格式返回日期和时间。这意味着时间格式中会包含AM和PM，但不会包含时区信息，<strong>具体的格式会因浏览器而异</strong>。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.toLocaleString()); <span class="comment">// 2018/3/20 上午10:33:32</span></span><br></pre></td></tr></table></figure></li><li><p>Date 类型的 toString() 方法会返回带有时区信息的日期和时间，其中时间一般以军用时间(范围0到23)表示。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(now.toString()); <span class="comment">// Tue Mar 20 2018 10:33:32 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></li><li><p>Date 类型的 valueOf() 方法会返回日期的毫秒表示，也就是时间戳。因此我们可以使用比较操作符来比较日期。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> data2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">3</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1 &lt; data2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在使用比较操作符，会隐式地调用 Date 对象的 valueOf() 方法，然后根据得到的毫秒数来进行比较。</p></li></ul><p>其实在实际应用中，使用 toLocaleString() 和 toString() 来显示日期时间是没有什么价值的，因为它们的返回的日期格式在不同的浏览器里大相径庭，无法得到一致化的显示结果，而且得到的格式对用户的交互效果也不是很友好。</p><h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><p>Date类型还有一些专门用来将日期转化为字符串的方法，不过与 toLocaleString() 和 toString() 的缺点一样，在平常的使用中没有多大价值，所以仅做一下了解就好。</p><ul><li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li><li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li><li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li><li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li><li>toUTCString()——以特定于实现的格式完整的UTC日期。</li></ul><h2 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h2><p>上面我们已经提到了，Date类型本身的字符串格式化方法很鸡肋，在日常使用中用处不大，所以一般我们只有自己编写适用于项目的 format 方法，这时我们一般需要用到获取日期中特定部分的方法。方法有点多，如下:</p><ul><li>getTime()<br>返回表示日期的毫秒数；与valueOf()方法返回的值相同</li><li>setTime(毫秒)<br>以毫秒数设置日期，会改变整个日期</li><li>getFullYear()<br>取得4位数的年份（如2007而非仅07）</li><li>getUTCFullYear()<br>返回UTC日期的4位数年份</li><li>setFullYear(年)<br>设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）</li><li>setUTCFullYear(年)<br>设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）</li><li>getMonth()<br>返回日期中的月份，其中0表示一月，11表示十二月</li><li>getUTCMonth()<br>返回UTC日期中的月份，其中0表示一月，11表示十二月</li><li>setMonth(月)<br>设置日期的月份。传入的月份值必须大于0，超过11则增加年份</li><li>setUTCMonth(月)<br>设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份</li><li>getDate()<br>返回日期月份中的天数（1到31）</li><li>getUTCDate()<br>返回UTC日期月份中的天数（1到31）</li><li>setDate(日)<br>设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</li><li>setUTCDate(日)<br>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</li><li>getDay()<br>返回日期中星期的星期几（其中0表示星期日，6表示星期六）</li><li>getUTCDay()<br>返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）</li><li>getHours()<br>返回日期中的小时数（0到23）</li><li>getUTCHours()<br>返回UTC日期中的小时数（0到23）</li><li>setHours(时)<br>设置日期中的小时数。传入的值超过了23则增加月份中的天数</li><li>setUTCHours(时)<br>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</li><li>getMinutes()<br>返回日期中的分钟数（0到59）</li><li>getUTCMinutes()<br>返回UTC日期中的分钟数（0到59）</li><li>setMinutes(分)<br>设置日期中的分钟数。传入的值超过59则增加小时数</li><li>setUTCMinutes(分)<br>设置UTC日期中的分钟数。传入的值超过59则增加小时数</li><li>getSeconds()<br>返回日期中的秒数（0到59）</li><li>getUTCSeconds()<br>返回UTC日期中的秒数（0到59）</li><li>setSeconds(秒)<br>设置日期中的秒数。传入的值超过了59会增加分钟数</li><li>setUTCSeconds(秒)<br>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</li><li>getMilliseconds()<br>返回日期中的毫秒数</li><li>getUTCMilliseconds()<br>返回UTC日期中的毫秒数</li><li>setMilliseconds(毫秒)<br>设置日期中的毫秒数</li><li>setUTCMilliseconds(毫秒)<br>设置UTC日期中的毫秒数</li><li>getTimezoneOffset()<br>返回本地时间与 UTC 时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化</li></ul><h2 id="时间戳的获取"><a href="#时间戳的获取" class="headerlink" title="时间戳的获取"></a>时间戳的获取</h2><p>在平时我们需要用到最多的地方还是时间戳的获取，上面我们也提到了不少可以的得到时间戳的方法，下面做一个归纳。</p><ul><li>使用 Date.now() 获取当前时间的毫秒数，只适用于当前时间。</li><li>使用 Date.parse() 获取指定时间的毫秒数，只适用于指定时间。</li><li>使用 Date.UTC() 获取指定时间的毫秒数，只适用于指定时间。</li><li>使用操作符 <code>+</code> 获取Date对象表示日期的毫秒数，都适用取决于Date对象。</li><li>使用 valueOf() 获取Date对象表示日期的毫秒数，都适用取决于Date对象。</li><li>使用 getTime() 获取Date对象表示日期的毫秒数，都适用取决于Date对象。</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>花了一些时间将 Date 类型的基础知识，稍微总结了一下。这一块还有很多内容，以后有时间还会对 Date 对象的格式化这个一块进行补充。通过总结发现了很多自己以前习惯性忽略的一些东西。还是希望通过这样的方式，把 JavaScript 这一块的基础打牢一点。不着急慢慢来 :)</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu9-1.jpg&quot; alt=&quot;JavaScript深入理解之Date类型详解 文章配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;Date 类型平常用得不是很多，但一用到，对它的使用就感到不是很熟悉，每次都是强行百度一波，可以看出自己的基础不是很牢。所以最近决定静下心来好好回顾一下以前自己忽视的基础，下面是我对 Date 类型的一些总结和看法。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="Date" scheme="http://cavszhouyou.top/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之Array类型详解</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之Array详解.html</id>
    <published>2018-03-16T11:40:12.000Z</published>
    <updated>2018-11-21T15:43:24.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu8-1.jpg" alt="JavaScript深入理解之Array详解 配图"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Array类型可以说是ECMAScript中最常用的一种类型了。和其他语言中的Array类型相比，ECMAScript中的Array类型可以说是厉害多了，它能比它们多做很多事情，当然也同样存在更多使用上的隐患。以前也遇到了很多关于Array使用上的问题，一直没有时间整理总结，下面总结一下我对Array的理解。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Array 对象用于在单个的变量中存储多个值。</p></blockquote><p><strong>与其他数组的不同:</strong></p><ul><li><p>ECMAScript 数组中的每一项都可以保存不同类型的数据，也就是说你可以第一个位置保存一个数值，第二个位置保存一个字符串，第三个位置保存一个Boolean值。只要你有需要，这样的数组都是合法的。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span> , <span class="string">"hello"</span> , <span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li><li><p>数组的长度大小是可变的，也就是说你可以随意的向数组增添数据，如果大小不够时，数组会自动增长以容纳新的数据。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span> , <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>创建数组的方式一共有两种。</p><ul><li><p>使用Array构造函数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//注意这里的new操作符是可省的</span></span><br></pre></td></tr></table></figure></li><li><p>使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间用逗号隔开。这种方法不会调用Array的构造函数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>] <span class="comment">//创建一个包含3项的数组</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>数组的项数保存在它的length属性中，这个属性不是只读的，也就是说我们可以通过修改这个属性来从数组末尾移除项或添加新的项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]) <span class="comment">// "white"</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">2</span>; <span class="comment">//通过减小数组的长度来移除末尾项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>利用length属性也可以很方便地在数组末尾添加新项，下面是我们平常使用最多的一种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>];</span><br><span class="line"></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>; <span class="comment">// 在数组，末尾添加新元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]); <span class="comment">// "black"</span></span><br></pre></td></tr></table></figure><h2 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h2><p>自从ES3做出规定以后，如何判断某个对象是否为数组就成为了一个经典问题。一共有两种方法可以判断。</p><ul><li><p>对于一个网页或者一个全局作用域而言，使用instanceof就可已解决问题。不过如果网页中存在多个框架，就意味着存在多个全局作用域,从而存在两个版本以上的Array的构造函数。如果我们从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中的原生创建的数组分别具有不同的构造函数，这种情况下就无法使用instanceof来判断了。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">    <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对上面的情况，ES5新增克Array.isArray()方法。这个方法可以最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">    <span class="comment">//对数组进行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p>在实际应用中，很多时候我们需要将数组转换为字符串的形式来表示，那么应该如何转换呢？将一个数组转化为字符串形式表示一共有三种方法。</p><ul><li><p>使用toString()方法。调用数组的toString()方法会返回数组的每个值的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个字符串，会调用数组的每一项的toString()方法。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red,blue,white</span></span><br></pre></td></tr></table></figure></li><li><p>使用toLocalString()方法。调用这个方法得到的结果其实和调用toString()方法得到的结果多数情况下是相同的。不同的是,使用该方法创建字符串时，会调用数组的每一项的toLocalString()方法，而不再是toString()方法。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.toLocalString()); <span class="comment">// red,blue,white</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用join()方法。在很多情况下，我们希望能够自己定义分隔符，这个时候使用join方法就很方便了。join方法接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。注意如果不传入参数，则默认使用逗号作为分隔符。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"||"</span>)); <span class="comment">// red||blue||white</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>我们知道栈是一种先进后出的数据结构，也就是最新添加的项最后被移除。而且栈中项的插入和移除只发生在一个位置——栈的顶部。ECMAScript为数组专门提供了push()和pop()方法，以此来实现类似栈的行为。</p><p>push()方法可以接收任意数量的参数，并把他们逐个添加到数组末尾，并返回修改后数组的长度。pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"green"</span>); <span class="comment">//入栈，推入一项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red","blue","green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 弹栈，弹出最后一项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red","blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure><h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>栈数据结构的访问规则是先进后出，而队列数据结构的访问规则是先进先出。队列在列表的末端添加项，从列表的前端移除项。由于push()方法已经实现了向数组末端添加项的方法，因此模拟队列只需要一个从数组前端获取项的方法就行了。实现这一操作的数组方法是shift(),它能够移除数据组中的第一个项并返回该项，同时将数组长度减一。结合使用shift()和push()方法，就可以像使用队列一样使用数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"green"</span>); <span class="comment">//入队列，推入一项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red","blue","green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift(); <span class="comment">// 出队列，移除数组第一项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["blue","green"]</span></span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure><p>ECMAScript还为数组提供了一个unshift()方法。这个方法的作用刚好和shift()方法相反，它能在数组前端添加任意个项并返回新数组的长度。因此使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p><h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>数值中有两种可以直接用来重排序的方法，一种是reverse()方法，另一种是sort()方法。</p><ul><li><p>reverse()方法可以反转数组项的顺序，注意该方法是直接在原始数组上进行操作的。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">numbers.reverse();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers); <span class="comment">// [9,8,7,6,5,4,3,2,1]</span></span><br></pre></td></tr></table></figure></li><li><p>sort()方法，在默认情况下会按升序序列排列数组项——即最小的值位于最前面，最大的值排在最后面。不过这个升序的比较，比较的不是数值的大小，为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定该如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">numbers.sort();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers); <span class="comment">// [0,1,10,15,5]</span></span><br></pre></td></tr></table></figure><p>  从上面的例子中可以看出，虽然数值5小于10，但在进行字符串比较时，”10”则位于”5”的前面，于是数组的顺序就修改了。这种方法显然大多数情况下不会符合我们的需要，那么有什么其他办法吗？其实sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。<br>  比较函数接收两个参数，如果第一个参数应该位于第二个参数则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">numbers.sort(compare);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers); <span class="comment">// [15,10,5,1,0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</span><br><span class="line">    retrun value2 - value1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>ECMAScript为数组操作提供了很多方法，这些方法在我们实际应用中经常会用到，下面我们来一一介绍。</p><h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat()方法"></a>concat()方法</h3><p>conact()方法可以基于当前数组中的所有项和传入参数构建一个新的数组。这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个参数的末尾，最后返回这个新的数组。需要注意的是:</p><ul><li>在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回脚本。</li><li>如果传递给concat()方法的是一个或多个数组，则该方法会将这些数组的每一项都添加到结果数组中。</li><li>如果传递的值不是数组这些值会被简单地添加到数组的末尾。</li><li>原始数组不受影响</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>,[<span class="string">"black"</span>,<span class="string">"brown"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(coloers2); <span class="comment">// red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure><h3 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice()方法"></a>slice()方法</h3><p>slice()方法它能够基于当前数组中的一个或多个项创建一个新数组，简单理解为可以用于截取数组中的一部分。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。需要注意的是：</p><ul><li>在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。</li><li>如果有两个参数，该方法返回起始位置和结束位置之间的项，<strong>但不包括结束位置的项</strong>。</li><li>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。</li><li>如果结束位置小于初始位置，则返回空数组</li><li>原始数组不受影响</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>,<span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> colors4 = colors.slice(<span class="number">-2</span>,<span class="number">-1</span>); <span class="comment">// 相当于调用slice(3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3); <span class="comment">// green,blue,yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(colors4); <span class="comment">// yellow</span></span><br></pre></td></tr></table></figure><h3 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice()方法"></a>splice()方法</h3><p>splice()方法可以说是最强大的数组方法了，它的用法有很多。splice()方法接受三个参数，起始位置，要删除的项数和要插入的任意数量的项，splice()方法始终会返回一个数组，该数组汇中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。使用这种方法的方式有如下三种:</p><ul><li><p>删除: 可以删除任意数量的项，只需要指定两个参数：起始位置和要删除的项数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">2</span>) <span class="comment">//删除数组中的前两项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// blue,yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(removed) <span class="comment">// red,green</span></span><br></pre></td></tr></table></figure></li><li><p>插入: 可以向指定位置插入任意数量的项，需要提供三个参数，起始位置，0(要删除的项数)和要插入的项。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"white"</span>,<span class="string">"black"</span>); <span class="comment">//从位置一开始插入两项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// red,white,black,green,blue,yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(removed) <span class="comment">// 返回的是一个空数组</span></span><br></pre></td></tr></table></figure></li><li><p>替换: 可以向指定位置插入任意数量的项。插入的项数不必和删除的项数相等，需要三个参数，起始位置，要删除的项数和要插入的任意数量的项。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"white"</span>,<span class="string">"black"</span>); <span class="comment">//删除位置一项，然后插入两项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// red,white,black,blue,yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// green</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>ES5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引(可选)。其中，indexOf()方法从数组的开头(位置0)开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。<br>这两个方法都是用于返回要查找的项在数组中第一次匹配到的位置，或者在没有找到的情况下返回-1。注意在比较第一个参数与数组中的每一项时，会使用全等操作符<code>===</code>，也就是说，要求查找的项必须严格相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.indexOf(<span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nmbers.indexOf(<span class="number">4</span>,<span class="number">4</span>)); <span class="comment">// 从位置4开始向后匹配</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>)) <span class="comment">// 从位置4开始向前匹配</span></span><br></pre></td></tr></table></figure><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>相信我们平时使用中，对数组操作最多的都是数组的遍历迭代。ES5中为数组定义了五个方法。每个方法都接收两个参数，要在数组没每一项上运行的函数和运行该函数的作用域对象——影响this的值(可选)。传入这些方法中的函数会接受三个参数：数组项的值，该项在数组中的位置和数组对象本身。根据使用方法的不同，这个函数执行后的返回值可能也可能不会影响方法的值。下面我们分别介绍这五个迭代方法，注意这些方法都不会修改原始数组包含的值。</p><h3 id="every-方法"><a href="#every-方法" class="headerlink" title="every()方法"></a>every()方法</h3><p>every()方法，该方法对数组中的每一项都运行给定函数，如果该函数对每一项都返回true，则返回true。这种方法适用于判断数组中的项是否都满足某个条件。该方法的返回值为Boolean。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断数组项否都小于10</span></span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item , index , array</span>)</span>&#123;</span><br><span class="line">    retrun item &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// true 证明数组项都小于10</span></span><br></pre></td></tr></table></figure></p><h3 id="some-方法"><a href="#some-方法" class="headerlink" title="some()方法"></a>some()方法</h3><p>some()方法，该方法对数组中的每一项运行给定函数，如果该函数汇中某一项返回true，则返回true。这种方法和every()方法使用很像，不过some()方法用于判断数组中是否含有满足某个条件的项。该方法的返回值为Boolean。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断数组中是否有小于10的项</span></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item , index , array</span>)</span>&#123;</span><br><span class="line">    retrun item &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someResult); <span class="comment">// true 证明数组中含有小于10的项</span></span><br></pre></td></tr></table></figure></p><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h3><p>filter()方法，对数组中的每一项运行给定函数，返回该函数会返回true的项的数组。这种方法适用于数组的过滤，得到数组中满足特定条件的项。该方法会返回一个包含符合条件项的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组中大于5的项</span></span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item , index , array</span>)</span>&#123;</span><br><span class="line">    retrun item &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filterResult); <span class="comment">// [6,7,8,9]</span></span><br></pre></td></tr></table></figure><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h3><p>map()方法，对数组的每一项运行给定函数，返回每次函数调用的结果的数组。这种方法使用在需要对数组中的元素整体进行一些操作的时候情况。该方法会返回一个对数组每项进行操作后的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组中的每一项的乘2</span></span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item , index , array</span>)</span>&#123;</span><br><span class="line">    retrun item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapResult); <span class="comment">// [2,4,6,8,10,12,14,16,18]</span></span><br></pre></td></tr></table></figure></p><h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h3><p>forEach()方法，对数组中的每一项运行给定函数。这种方法本质上与for循环迭代数组一样。这个方法没有返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item , index , array</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ES5中新增了两个归并数组的方法: reduce() 和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight方法则从数组的最后一项开始，向前遍历到第一项。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和作为归并基础的特殊值(可选)。传入reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象这个函数返回的任何值都会作为第一个参数自动传给下一项，也就是说第一个参数均为上一次迭代返回的结果。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项。第二个参数就是数组的第二项。使用reduce() 和 reduceRight()方法可以执行求数组中所有值之和的操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, cur, index, arrray</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sumRight = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">pre, cur, index, arrray</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumRight); <span class="comment">//15</span></span><br></pre></td></tr></table></figure></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>不总结不知道，一种总结才发现Array涉及到的知识点和用法真的太多了。以前只会使用一些简单的循环来判断，没有发现其实ECMAScript已经为我们提供了很多方便的方法。这样总结了一下，感觉对Array对象的认识更深了一些，收获挺大的。希望我的学习总结可以给你带来帮助。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu8-1.jpg&quot; alt=&quot;JavaScript深入理解之Array详解 配图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;Array类型可以说是ECMAScript中最常用的一种类型了。和其他语言中的Array类型相比，ECMAScript中的Array类型可以说是厉害多了，它能比它们多做很多事情，当然也同样存在更多使用上的隐患。以前也遇到了很多关于Array使用上的问题，一直没有时间整理总结，下面总结一下我对Array的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="Array" scheme="http://cavszhouyou.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解之undefined与null</title>
    <link href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html"/>
    <id>http://cavszhouyou.top/JavaScript深入理解之undefined与null.html</id>
    <published>2018-03-10T02:59:26.000Z</published>
    <updated>2018-11-21T15:43:24.821Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu7-1.jpg" alt="配图7-1"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>JavaScript中有两个特殊的值，undefined与null。平常在写项目时，遇到需要判断一个值是否为空的时候，我总会想到undefined与null。既然都是代表空值(以前我就是这么认为的)，那么它们有没有区别呢？反正我是一直傻傻分不清楚，看了又忘了。最近查阅了一些资料，才发现自己以前真的是误解它们了，知错就改，下面总结一下它们的用法和区别。</p><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>在介绍undefined与null之前，我们先来了解一下ECMAScript中的数据类型。在ECMAScript中有五种简单数据类型(也称为基本数据类型): Undefined、Null、Boolean、Number 和 String 。还有一种复杂数据类型——Object。</p><p>没错，首字母大写的Undefined与Null其实都属于ECMAScript中的基本数据类型。这两个数据类型是五种数据类型中最特殊的两个类型，因为它们都只有唯一的一个值，分别是undefined与null，就是我们今天要介绍的两个主角。</p><h2 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>上面我们说过了，Undefined类型只有一个值，就是特殊的undefined，在两种情况下我们会得到undefined：</p><ol><li><p>声明了一个变量，但未对其初始化时，这个变量的值就是undefined。</p><pre><code class="js"><span class="keyword">var</span> data;<span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">//true</span></code></pre><p>那么我么是否可以显式地把一个变量初始化为undefined呢，答案是可以的。</p><pre><code class="js"><span class="keyword">var</span> data = <span class="literal">undefined</span>;<span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">//true</span><span class="keyword">var</span> value = <span class="number">1</span>;<span class="built_in">console</span>.log(data); <span class="comment">//1</span>value = <span class="literal">undefined</span>;<span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">// true</span></code></pre><p>一般而言，我们不存在需要显式地把一个变量设置为undefined值的情况，因为对于未经初始化的值默认就会取得undefined值，而已经初始化的值再将其赋值为undefined来表示空值是没有意义且不可取的。况且字面值undefined的主要目的以用于比较，来区分空对象指针(后面我们会介绍到这指的就是null)与未经初始化的变量的情况。</p></li><li><p>对未定义的变量执行typeof操作符也会返回undefined</p><pre><code class="js"><span class="comment">//data变量未定义</span><span class="keyword">var</span> value;<span class="built_in">console</span>.log(<span class="keyword">typeof</span> data); <span class="comment">// "undefined"</span><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">// "undefined"</span></code></pre><p>这里我们没有使用<code>===</code>来判断，因为对于尚未声明过的变量，我们只能执行一项操作，即使用typeof操作符检测其数据类型，使用其他的操作都会报错。</p><pre><code class="js"><span class="comment">//data变量未定义</span><span class="built_in">console</span>.log(data === <span class="literal">undefined</span>); <span class="comment">//报错</span></code></pre><p>结果表明对未初始化和未声明的变量执行typeof操作符都返回了undefined值，这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p></li></ol><p>还有其他几种情况也会返回undefined，比如一个函数如果没有使用return语句指定返回值，就会返回一个undefined值，或者调用函数时没有传参数值，参数同样也会被初始化为undefined值。这些都是属于上面两种情况在代码中的体现，这里就不单独解释了。 </p><h3 id="全局属性-window-undefined"><a href="#全局属性-window-undefined" class="headerlink" title="全局属性 window.undefined"></a>全局属性 window.undefined</h3><p>从上面的例子我们可以看出，无论我们是否初始化过变量，都可以给变量赋值为undefined。其实这里用于赋值的undefined不是一个值，它是一个属性名，undefined是全局对象的一个属性，也就是说，它是全局作用域的一个变量，即<code>window.undefined</code>，而<code>window.undefined</code>这个属性的值才是前面所说的原始值undefined。<code>data = undefined;</code>这就相当于把一个变量<code>window.undefined</code>的值赋值给另一个变量<code>data</code>，这个值就是原始值undefined。其实在JavaScript代码中,我们看到的undefined大多数情况指的都是<code>window.undefined</code>(本篇文章中多数情况下也是，原始值undefined除外)，原始值undefined多数情况下只存在于文档或规范中,不存在于JavaScript代码中(具体可以理解为代码中参与判断、比较或赋值的都是<code>window.undefined</code>，而在控制台中输出，或函数中返回的则是原始值undefined)。</p><pre><code class="js"><span class="built_in">console</span>.log(<span class="built_in">window</span>.undefined); <span class="comment">//原始值undefined</span></code></pre><p>注意，在ES3之前其实是没有原始值undefined这个值的，第三版引入这个值，其实是为了正式区分空对象指针(后面我们会介绍到这指的就是null)与未经初始化的变量。在ES3中,<code>window.undefined</code>就是一个普通的属性，我们完全可以把它的值改为任何真值。但从ES5之后,<code>window.undefined</code>成了一个不可写,不可配置的数据属性,它的值永远是undefined。</p><h3 id="局部属性-undefined"><a href="#局部属性-undefined" class="headerlink" title="局部属性 undefined"></a>局部属性 undefined</h3><p>大家可能注意到了，上面我提到的是在大多数情况下undefined指的都是<code>window.undefined</code>，那还有什么其他情况吗？其实在ECMAScript中，undefined不是一个保留字，这意味着什么呢？也就是说我们可以将undefined作为一个局部变量来使用，就像局部作用域中任何其他普通变量一样，没有任何特殊性，我们可以对其赋予任何类型的值。</p><pre><code class="js">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{    <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'not is undefined'</span>;    <span class="built_in">console</span>.log(<span class="literal">undefined</span>); <span class="comment">//"not is undefined"</span>    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// "string"</span>})()</code></pre><p>我们可以看到undefined的值和类型都已经改变，这样的做法是非常不友好的，这样会使我们的代码难以维护和排错。</p><h3 id="undefined-判断"><a href="#undefined-判断" class="headerlink" title="undefined 判断"></a>undefined 判断</h3><p>如何判断一个变量是否为undefined，这里有两种方法。</p><ol><li><p>使用严格相等符<code>===</code>或不相等操作符<code>!==</code>来决定一个变量是否拥有值，这里不使用标准相等操作符<code>==</code>,是因为标准相等符还会会检查变量是不是为null，但是严格相等操作符不会检查。null不等同于undefined，这点我们会在后面讲到。</p></li><li><p>使用typeof操作符，这种方式我们在上面已经使用过了，对未定义的变量检测时只能使用这种方式，要不然会出现报错。</p></li></ol><h3 id="void-0"><a href="#void-0" class="headerlink" title="void 0"></a>void 0</h3><p>上面我们提到过了，undefined作为局部变量使用是可以被重写的，那么如果我们使用下面这种判断方式，是有风险的。</p><pre><code class="js"><span class="keyword">if</span>(data === <span class="literal">undefined</span>){    <span class="comment">//do something</span>}</code></pre><p>那么我们怎样做才能确保万无一失呢?让我们先来了解一下void运算符,官方文档是这样解释的:</p><blockquote><p>The void operator evaluates the given expression and then returns undefined.</p><p>void 运算符 对给定的表达式进行求值，然后返回 undefined</p></blockquote><p>什么意思呢？就是使用void对后面的表达式求值，无论结果是多少，都会返回原始值undefined。因此我们可以用<code>void 0</code>来代替undefined进行判断，因为<code>void 0</code>始终返回的都是原始值undefined。</p><pre><code class="js"><span class="keyword">var</span> data;<span class="built_in">console</span>.log(data === <span class="keyword">void</span> <span class="number">0</span>); <span class="comment">//true</span></code></pre><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Null类型是第二个只有一个值的数据类型，这个特殊的值就是null。值 null 是一个字面量，它不像undefined 是全局对象的一个属性。从逻辑角度来看，null值表示一个空对象指针，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。在 APIs 中，null 常在返回类型是对象，但没关联值的地方使用，就像下面一个例子。</p><pre><code class="js"><span class="comment">//document.getElementById() 可以返回对拥有指定 ID 的第一个对象的引用</span><span class="keyword">var</span> $container = <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>); <span class="comment">// 注意:container是不存在的</span><span class="built_in">console</span>.log($container); <span class="comment">// null</span></code></pre><h3 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h3><p>当我们使用typeof操作符检测null值，我们理所应当地认为应该返”Null”类型呀，但是事实返回的类型却是”object”。</p><pre><code class="js"><span class="keyword">var</span> data = <span class="literal">null</span>;<span class="built_in">console</span>.log(<span class="keyword">typeof</span> data); <span class="comment">// "object"</span></code></pre><p>是不是很奇怪？其实我们可以从两方面来理解这个结果</p><ul><li><p>一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回”object”也是可以理解的。</p></li><li><p>另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。在ES6中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持”object”类型。</p></li></ul><h3 id="null-判断"><a href="#null-判断" class="headerlink" title="null 判断"></a>null 判断</h3><p>null的判断可以使用严格相等符<code>===</code>或不相等操作符<code>!==</code>判断，不使用标准相等符的原因是因为undefined会影响判断结果。和undefined不一样，不能使用typeof来判断一个值是否为null，原因上边已经讲了，使用typeof来检测null会返回”object”,这样的话我们是没办法判断的。</p><pre><code class="js"><span class="keyword">if</span>(data === <span class="literal">null</span>){    <span class="built_in">console</span>.log(<span class="string">"data中没有保存对象引用！"</span>);}</code></pre><h3 id="null-使用"><a href="#null-使用" class="headerlink" title="null 使用"></a>null 使用</h3><p>那么我们在什么情况下需要将变量赋值为null呢？这里我想到的有两种情况。</p><ul><li><p>如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。</p></li><li><p>当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。</p></li></ul><h2 id="undefined-与-null"><a href="#undefined-与-null" class="headerlink" title="undefined 与 null"></a>undefined 与 null</h2><p>实际上undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true:</p><pre><code class="js"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></code></pre><p>因为使用的是标准相等符<code>==</code>,这个操作符出于目的会转换其操作数为相同类型后再做比较，如果我们使用严格相等符比较，我们会发现它们是不相等的，因为严格相等符不会进行类型转换，然而undefined与null属于不同的类型，所以不相等。</p><pre><code class="js"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">//false</span></code></pre><p>尽管null和undefined有这样的关系，但上面我们已经提到过了，它们的用途完全不同，我们在平常使用时一定要学会区分。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《JavaScript高级程序设计(第三版)》<br> <a href="http://www.css88.com/archives/6236" target="_blank" rel="noopener">JavaScript中undefined和null的区别</a><br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener">JavaScript 参考文档 null</a><br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener">JavaScript 参考文档 undefined</a><br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">JavaScript 参考文档 typeof</a><br> <a href="https://juejin.im/post/591153ceac502e450281e22f" target="_blank" rel="noopener">(void 0) 与 undefined 之间的小九九</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>花了一些时间来总结undefined与null的用法和区别，以前一直没有注意，经过这次总结才发现它们所代表的的意义和用法完全不同。可能在平常使用的时候我们不需要考虑这么多问题，但通过重新看一些东西，总结一些东西，通过这样的方式对我来说收获挺大的。</p><p><strong>本篇文章纯属于个人的学习总结，如果文章中出现错误或不严谨的地方，希望大家能够指出，谢谢！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu7-1.jpg&quot; alt=&quot;配图7-1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;JavaScript中有两个特殊的值，undefined与null。平常在写项目时，遇到需要判断一个值是否为空的时候，我总会想到undefined与null。既然都是代表空值(以前我就是这么认为的)，那么它们有没有区别呢？反正我是一直傻傻分不清楚，看了又忘了。最近查阅了一些资料，才发现自己以前真的是误解它们了，知错就改，下面总结一下它们的用法和区别。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="前端" scheme="http://cavszhouyou.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://cavszhouyou.top/tags/JavaScript/"/>
    
      <category term="数据类型" scheme="http://cavszhouyou.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="undefined" scheme="http://cavszhouyou.top/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>那些自律到极致的人，都拥有了开挂的人生</title>
    <link href="http://cavszhouyou.top/%E9%82%A3%E4%BA%9B%E8%87%AA%E5%BE%8B%E5%88%B0%E6%9E%81%E8%87%B4%E7%9A%84%E4%BA%BA%EF%BC%8C%E9%83%BD%E6%8B%A5%E6%9C%89%E4%BA%86%E5%BC%80%E6%8C%82%E7%9A%84%E4%BA%BA%E7%94%9F.html"/>
    <id>http://cavszhouyou.top/那些自律到极致的人，都拥有了开挂的人生.html</id>
    <published>2018-02-22T04:19:48.000Z</published>
    <updated>2018-11-21T15:43:25.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-1.jpg" alt="配图6-1"></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天早上起床看到了这篇文章，感触很多。一直想做一个自律的人，拥有一个自律的、向上的生活。但往往我会在下定决心的第二天、第三天就选择放弃。不是不知道自己想要什么，只是自己更多的选择了随波逐流的安逸。每天都浑浑噩噩的混过一天，让人很难接受。我希望自己的生活有所改变，谨以此文勉励自己，不要在最该奋斗的年纪蹉跎了芳华。</p><a id="more"></a><blockquote><p>我从来不相信什么懒洋洋的自由。我向往的自由是通过勤奋和努力实现的更广阔的人生。我要做一个自由又自律的人，靠势必实现的决心认真地活着。不要做欲望的奴隶，自律可以令我们活得更高级。</p></blockquote><h2 id="一、自律，可以让我们活得更高级"><a href="#一、自律，可以让我们活得更高级" class="headerlink" title="一、自律，可以让我们活得更高级"></a>一、自律，可以让我们活得更高级</h2><p>在新的一年，做到自律，你才能活得更高级。</p><p>前些天，男神钟汉良在一天内发了 4 条微博，晒出了他的早餐、午餐和晚餐。</p><blockquote><p>早餐是一片吐司加蛋，外加两颗蘑菇和圣女果。</p><p>午餐是满满的一盘蔬菜，搭配米兰大教堂形状的意大利面。</p><p>晚餐是自制蔬菜沙拉和燕麦小点心。</p></blockquote><p>清淡又营养的三餐里，藏着他在饮食方面的自律。</p><p>出道 20 多年，钟汉良始终保持着良好的身材和不变的容颜。连见多识广的记者、节目主持人也惊叹于他皮肤的质感，调侃他是不是睡在冰箱里。</p><p>然而，正如泰迪·罗斯福所说：“有了自律能力，没有什么事情是你做不到的。”</p><p>多少人羡慕着别人的身材与样貌，羡慕着别人的成功与精彩。但是当了解到其背后付出的艰辛和近乎残酷的自我管理后，又迅速打起了退堂鼓。在浑浑噩噩、随波逐流的日子里，继续毫无意义地耗费生命。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-2.webp" alt="配图6-2"></p><p>知乎上有这样一个问题：你最深刻的错误认识是什么？</p><p>点赞最高的回答是：以为自由就是想做什么就做什么，后来才发现自律者才会有自由。</p><p>当一个人缺乏自律的时候，他做的事情总是在受习惯和及时诱惑的影响，要么就是被他人的思想观念所扰，几乎永远不可能去做内心真正渴望的事。</p><p>你会发现：那些自律到极致的人，都拥有了开挂的人生。</p><h2 id="二、自律，是解决人生问题的首要方案"><a href="#二、自律，是解决人生问题的首要方案" class="headerlink" title="二、自律，是解决人生问题的首要方案"></a>二、自律，是解决人生问题的首要方案</h2><p>谷歌有位高级工程师，叫马特·卡茨。</p><p>他给自己定下了一个 30 天改变的计划，每天做一些之前未能坚持的事。</p><p>比如：每天骑自行车上班，每天步行 10000 步，每天拍一张照片，写一本 5 万字的小说；</p><p>不看电视，不吃糖，不玩推特，拒绝咖啡因…..</p><p>可以说这份计划充满了挑战性，做不到自律的人势必无法完成。</p><p>但马特坚持了下来。</p><p>30 天后，昔日那个肥腻的宅男工程师不见了，他开始发自内心地喜欢上骑自行车去工作，甚至完成了在非洲最高峰乞力马扎罗山的远足。</p><p>心理学家曾经总结过这样的规律：</p><p>自律的前期是兴奋的，中期是痛苦的，后期是享受的。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-3.webp" alt="配图6-3"></p><p>但有没有发现，大部分人都在自律的中期——痛苦期徘徊太久，以至于把痛苦当作是自律。</p><p>而当你自律到极致，你会发现：自律能够带给你发自内心的平静和享受。</p><p>因为你知道，自己在一天天地改变，自律已经变成了一种深入骨髓的习惯。</p><p>正如李开复所说：“千万不要放纵自己，给自己找借口。对自己严格一点，时间长了，自律便成为一种习惯，一种生活方式，你的人格和智慧也因此变得更加完美。”</p><p>《少有人走的路》里有这样一句话：</p><p>解决人生问题的首要方案，乃是自律。缺少了这一环，你不可能解决任何麻烦和困难。</p><p>那么，如何才能将自律坚持到极致？</p><h2 id="三、自律，其实并没有那么难"><a href="#三、自律，其实并没有那么难" class="headerlink" title="三、自律，其实并没有那么难"></a>三、自律，其实并没有那么难</h2><p>《毅力——如何培养自律的习惯》这本书中介绍了 3 种方法，更新了我对自律的认知。</p><p>① 设立具体目标，坚持无一例外原则</p><p>我的表妹小蕊，每天嚷嚷着减肥，却从未成功过。</p><p>原因之一，想必就在于没有设定具体的目标。</p><p>无数研究显示：当人们用具体的条文对他们的目标进行定义后，他们成功的可能性就会大大增加。</p><p>大多数制定了明确目标的减肥者（比如：我要在 2 个月内瘦下 10 斤），会比那些目标含糊不清的减肥者减肥效果要好得多。</p><p>目标明确是很重要的，因为明确的目标可以减少思想上的歧义和执行中的变异。</p><p>设定目标之后，需要坚持“无一例外”的原则。</p><p>比方说，目标是在 2 个月内瘦下 10 斤，就坚持在达到减肥目标之前，一点甜点都不吃。</p><p>如果不坚持这项原则，那么每次面对甜点时，都必须决定是否要放纵自己。</p><p>在进行考虑的过程中，将会耗费能量，而这些能量，是维持毅力的关键。</p><p>所以，一旦给自己下了绝对不破例的原则，就不会再把能量花在一遍又一遍、无休止的自我纠结上。</p><p>那些自律到极致的人，都坚持了无一例外原则。</p><blockquote><p>蔡依林从不吃任何有油的食品，甚至有三年的时间内没有吃过米饭；</p><p>杨丽萍为了呈现最完美的舞蹈，几乎没有吃过一顿饱饭；</p><p>刘德华为了保持身材，几十年来都保持着每天一杯酸奶的习惯。</p></blockquote><p>一旦你对某件事情百分之百地投入，那就不可能再有例外。事情已成定局，再也没有商量的余地。</p><p>放纵如山倒，自律如抽丝。</p><p>不要给自己找借口放纵，对自己严格一点，让自律成为一种习惯、原则。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-4.webp" alt="配图6-4"></p><p>② 一次只完成一项任务，不要过多消耗毅力</p><p>在改变自己的道路上，许多人会一次性给自己定下太多目标：</p><p>比如，半年内练出马甲线、考过 XX 考试、看 50 本书、看美剧不需要字幕……</p><p>然而，毅力就像人的肌肉一样，会产生疲劳。同时接受太多挑战，通常无法坚持实施下去。</p><p>有一个著名的实验：</p><p>100 个人被随机分为三组。</p><p>A 组中的每个成员都得到了一盘小萝卜，并被要求全部吃光。</p><p>B 组中的每个成员都得到了一盘饼干，并被要求全部吃光。</p><p>C 组中的每个成员可以选择他想要吃的东西，或者什么都不吃。</p><p>在所有的萝卜和饼干都被吃光以后，每个人都被要求解答同一道难题，这道难题实际上根本没有答案。</p><p>B 组和 C 组的人在猜了大约 15 分钟之后放弃，A 组的人只猜了 7 分钟就缴械投降了。</p><p>研究者从这次实验中得出结论：A 组成员已经耗尽了所有的毅力去吃掉那些萝卜，而 B 组和 C 组成员仍有大量的毅力去解那道难题。</p><p>意志力就像手机的剩余电量一样。</p><p>每天早晨你都是充满电的，随着你不断使用你的电力，最后电力耗尽，你也就毫无意志力可言。</p><p>你在一件事上用的意志力太多，不等它恢复就投入下一件事，那么肯定会疲惫不堪。</p><p>注意保存你的意志力，以便在最需要的时候使用。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-5.webp" alt="配图6-5"></p><p>③ 把挑战分解成小而易于管理的目标</p><p>太多人幻想着能够一蹴而就，一夜之间达成目标。</p><p>当完成一个任务所需的时间跨度很长、难度很大时，许多人容易半途而废。</p><p>这个时候，需要学会对任务进行分解。</p><p>日本著名的马拉松运动员山田本一，曾在自传中写到自己成功的秘密：</p><blockquote><p>每次比赛前，我都要乘车把比赛的路线仔细看一遍，并把沿途比较醒目的标志画下来。比如，第一标志是银行，第二标志是古怪的大树，第三标志是一座高楼……<br>这样一直画到赛程的结束。比赛开始后，我就奋力向第一个目标冲去，到达第一个目标后，我又以同样的速度向第二个目标冲去。<br>40 多公里的赛程，被我分解成几个小目标，跑起来就轻松多了。开始我把我的目标定在终点线的旗帜上，结果跑到十几公里的时候就疲惫不堪了，因为我被前面那段遥远的路吓到了。</p></blockquote><p>通往目的地的道路是由许多细小的、易于管理的步骤组成的。</p><p>不要总想着毕其功于一役。</p><p>慢一点、稳一点，关键在于把大目标分解成易于消化、循序渐进的小目标。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-6.webp" alt="配图6-6"></p><h2 id="四、自律，人生自由的必经之路"><a href="#四、自律，人生自由的必经之路" class="headerlink" title="四、自律，人生自由的必经之路"></a>四、自律，人生自由的必经之路</h2><p>以前总觉得，人生苦短，应及时行乐。</p><p>今朝有酒今朝醉，人不风流枉少年。</p><p>直到后来，我渐渐发现：</p><p>每一个不自律的行为，都会给你带来更大的痛苦。</p><p>长期暴饮暴食、缺乏运动，会让你不得不为自己的健康付出代价；</p><p>熬夜打游戏、刷微博，带来的是第二天的无精打采、浑浑噩噩；</p><p>没有目标、得过且过，会让你迷失方向、日渐空虚。</p><p>设计师山本耀司说：</p><p>我从来不相信什么懒洋洋的自由。我向往的自由是通过勤奋和努力实现的更广阔的人生。</p><p>我要做一个自由又自律的人，靠势必实现的决心认真地活着。</p><p>不要做欲望的奴隶，自律可以令我们活得更高级。</p><p>新的一年，成为自律的人，共勉。</p><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://mp.weixin.qq.com/s?srcid=0217Q148n0ebl25FBA6Oou2Q&amp;scene=22&amp;mid=2653195930&amp;sn=4c6b75245c3c8afe581917d42287740e&amp;idx=1&amp;__biz=MzA4MjAxODMzMA%3D%3D&amp;chksm=845c07efb32b8ef917c3fd98b6fb1e88ecef3bda01318e83327b6f7071d27ab392deff5e3566&amp;mpshare=1#rd" target="_blank" rel="noopener">那些自律到极致的人，都拥有了开挂的人生——原文地址</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我从来不相信什么懒洋洋的自由。我向往的自由是通过勤奋和努力实现的更广阔的人生。以此共勉！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=504835560&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/peitu6-1.jpg&quot; alt=&quot;配图6-1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;今天早上起床看到了这篇文章，感触很多。一直想做一个自律的人，拥有一个自律的、向上的生活。但往往我会在下定决心的第二天、第三天就选择放弃。不是不知道自己想要什么，只是自己更多的选择了随波逐流的安逸。每天都浑浑噩噩的混过一天，让人很难接受。我希望自己的生活有所改变，谨以此文勉励自己，不要在最该奋斗的年纪蹉跎了芳华。&lt;/p&gt;
    
    </summary>
    
      <category term="心得感悟" scheme="http://cavszhouyou.top/categories/%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://cavszhouyou.top/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="自律" scheme="http://cavszhouyou.top/tags/%E8%87%AA%E5%BE%8B/"/>
    
  </entry>
  
</feed>
